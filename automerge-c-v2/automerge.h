#ifndef automerge_h
#define automerge_h

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdint.h>
#include <stdbool.h>

typedef struct Backend Backend;

typedef struct SyncState SyncState;

/**
 * A sequence of byte buffers that are contiguous in memory
 * The C caller allocates one of these with `create_buffs`
 * and passes it into each API call. This prevents allocating memory
 * on each call. The struct fields are just the constituent fields in a Vec
 * This is used for returning data to C.
 */
typedef struct {
  /**
   * A pointer to the bytes
   */
  uint8_t *data;
  /**
   * The amount of meaningful bytes
   */
  uintptr_t len;
  /**
   * The total allocated memory `data` points to
   * This is needed so Rust can free `data`
   */
  uintptr_t cap;
} Buffer;

/**
 * # Safety
 * This should be called with a valid pointer to a `Backend`
 * `CBuffers` should be non-null & have valid fields.
 */
intptr_t automerge_apply_changes(Backend *backend, Buffer *buffs, const uint8_t *changes, uintptr_t changes_len);

/**
 * # Safety
 * This should be called with a valid pointer to a `Backend`
 * and a valid pointer to a `Buffers``
 */
intptr_t automerge_apply_local_change(Backend *backend, Buffer *buffs, const uint8_t *request, uintptr_t len);

/**
 * # Safety
 * This should be called with a valid pointer to a `Buffer`
 */
const uint8_t *automerge_buff_get_data(const Buffer *buf);

/**
 * # Safety
 * This should be called with a valid pointer to a `Buffer`
 */
uintptr_t automerge_buff_get_len(const Buffer *buf);

/**
 * # Safety
 * This should be called with a valid pointer to a `Backend`
 */
Backend *automerge_clone(Backend *backend);

/**
 * Create a `Buffers` struct to store return values
 */
Buffer *automerge_create_buff(void);

/**
 * # Safety
 * This must me called with a valid pointer to a change and the correct len
 */
intptr_t automerge_decode_change(Backend *backend, Buffer *buffs, const uint8_t *change, uintptr_t len);

/**
 * # Safety
 * `encoded_state_[ptr|len]` must be the address & length of a byte array
 */
SyncState *automerge_decode_sync_state(const uint8_t *encoded_state_ptr, uintptr_t encoded_state_len, intptr_t *error_code);

/**
 * # Safety
 * This must me called with a valid pointer to a JSON string of a change
 */
intptr_t automerge_encode_change(Backend *backend, Buffer *buffs, const uint8_t *change, uintptr_t len);

/**
 * # Safety
 * Must be called with a pointer to a valid Backend, sync_state, and buffs
 */
intptr_t automerge_encode_sync_state(Buffer *buffs, SyncState *sync_state);

/**
 * # Safety
 * This must be called with a valid backend pointer
 */
const char *automerge_error(Backend *backend);

/**
 * # Safety
 * This must be called with a valid backend pointer
 */
void automerge_free(Backend *backend);

/**
 * # Safety
 * Must point to a valid `Buffers` struct
 * Free the memory a `Buffers` struct points to
 */
intptr_t automerge_free_buff(Buffer *buffs);

/**
 * # Safety
 * Must be called with a valid backend pointer
 * sync_state must be a valid pointer to a SyncState
 * Returns an `isize` indicating the length of the binary message
 * (-1 if there was an error, 0 if there is no message)
 */
intptr_t automerge_generate_sync_message(Backend *backend, Buffer *buffs, SyncState *sync_state);

/**
 * # Safety
 * This must be called with a valid backend pointer,
 * binary must be a valid pointer to `hashes` hashes
 */
intptr_t automerge_get_changes(Backend *backend, Buffer *buffs, const uint8_t *bin, uintptr_t hashes);

/**
 * # Safety
 * This must be called with a valid pointer to a `Backend`
 * and a valid C String
 */
intptr_t automerge_get_changes_for_actor(Backend *backend, Buffer *buffs, const char *actor);

/**
 * # Safety
 * This must be called with a valid backend pointer
 */
intptr_t automerge_get_heads(Backend *backend, Buffer *buffs);

/**
 * # Safety
 */
intptr_t automerge_get_last_local_change(Backend *backend, Buffer *buffs);

/**
 * # Safety
 * This must be called with a valid backend pointer,
 * binary must be a valid pointer to len bytes
 */
intptr_t automerge_get_missing_deps(Backend *backend, Buffer *buffs, const uint8_t *bin, uintptr_t len);

/**
 * # Safety
 * This should be called with a valid pointer to a `Backend`
 * and a valid pointer to a `Buffers``
 */
intptr_t automerge_get_patch(Backend *backend, Buffer *buffs);

Backend *automerge_init(void);

/**
 * # Safety
 * This must be called with a valid pointer to len bytes
 */
Backend *automerge_load(const uint8_t *data, uintptr_t len);

/**
 * # Safety
 * This should be called with a valid pointer to a `Backend`
 * and a valid pointers to a `CBuffers`
 */
intptr_t automerge_load_changes(Backend *backend, const uint8_t *changes, uintptr_t changes_len);

/**
 * # Safety
 * Must be called with a valid backend pointer
 * sync_state must be a valid pointer to a SyncState
 * `encoded_msg_[ptr|len]` must be the address & length of a byte array
 */
intptr_t automerge_receive_sync_message(Backend *backend,
                                        Buffer *buffs,
                                        SyncState *sync_state,
                                        const uint8_t *encoded_msg_ptr,
                                        uintptr_t encoded_msg_len);

/**
 * # Safety
 * This should be called with a valid pointer to a `Backend`
 */
intptr_t automerge_save(Backend *backend, Buffer *buffs);

/**
 * # Safety
 * sync_state must be a valid pointer to a SyncState
 */
void automerge_sync_state_free(SyncState *sync_state);

SyncState *automerge_sync_state_init(void);

/**
 * # Safety
 * This must be called with a valid C-string
 */
intptr_t debug_json_change_to_msgpack(const char *change, uint8_t **out_msgpack, uintptr_t *out_len);

/**
 * # Safety
 * This must be called with a valid pointer to len bytes
 */
intptr_t debug_msgpack_change_to_json(const uint8_t *msgpack, uintptr_t len, uint8_t *out_json);

/**
 * # Safety
 * `prefix` & `buff` must be valid pointers
 */
void debug_print_msgpack_patch(const char *prefix, const uint8_t *buff, uintptr_t len);

#endif /* automerge_h */
