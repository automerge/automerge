#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2018::*;
#[macro_use]
extern crate std;
pub mod error {
    use thiserror::Error;
    use crate::{DataType, ScalarValue, ScalarValueKind};
    #[error("Invalid OpID: {0}")]
    pub struct InvalidOpId(pub String);
    #[allow(unused_qualifications)]
    impl std::error::Error for InvalidOpId {}
    #[allow(unused_qualifications)]
    impl std::fmt::Display for InvalidOpId {
        #[allow(clippy::used_underscore_binding)]
        fn fmt(&self, __formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
            #[allow(unused_imports)]
            use thiserror::private::{DisplayAsDisplay, PathAsDisplay};
            #[allow(unused_variables, deprecated)]
            let Self(_0) = self;
            __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                &["Invalid OpID: "],
                &match (&_0.as_display(),) {
                    (arg0,) => [::core::fmt::ArgumentV1::new(
                        arg0,
                        ::core::fmt::Display::fmt,
                    )],
                },
            ))
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for InvalidOpId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                InvalidOpId(ref __self_0_0) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "InvalidOpId");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    #[error("Invalid object ID: {0}")]
    pub struct InvalidObjectId(pub String);
    #[allow(unused_qualifications)]
    impl std::error::Error for InvalidObjectId {}
    #[allow(unused_qualifications)]
    impl std::fmt::Display for InvalidObjectId {
        #[allow(clippy::used_underscore_binding)]
        fn fmt(&self, __formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
            #[allow(unused_imports)]
            use thiserror::private::{DisplayAsDisplay, PathAsDisplay};
            #[allow(unused_variables, deprecated)]
            let Self(_0) = self;
            __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                &["Invalid object ID: "],
                &match (&_0.as_display(),) {
                    (arg0,) => [::core::fmt::ArgumentV1::new(
                        arg0,
                        ::core::fmt::Display::fmt,
                    )],
                },
            ))
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for InvalidObjectId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                InvalidObjectId(ref __self_0_0) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "InvalidObjectId");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for InvalidObjectId {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for InvalidObjectId {
        #[inline]
        fn eq(&self, other: &InvalidObjectId) -> bool {
            match *other {
                InvalidObjectId(ref __self_1_0) => match *self {
                    InvalidObjectId(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &InvalidObjectId) -> bool {
            match *other {
                InvalidObjectId(ref __self_1_0) => match *self {
                    InvalidObjectId(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[error("Invalid element ID: {0}")]
    pub struct InvalidElementId(pub String);
    #[allow(unused_qualifications)]
    impl std::error::Error for InvalidElementId {}
    #[allow(unused_qualifications)]
    impl std::fmt::Display for InvalidElementId {
        #[allow(clippy::used_underscore_binding)]
        fn fmt(&self, __formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
            #[allow(unused_imports)]
            use thiserror::private::{DisplayAsDisplay, PathAsDisplay};
            #[allow(unused_variables, deprecated)]
            let Self(_0) = self;
            __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                &["Invalid element ID: "],
                &match (&_0.as_display(),) {
                    (arg0,) => [::core::fmt::ArgumentV1::new(
                        arg0,
                        ::core::fmt::Display::fmt,
                    )],
                },
            ))
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for InvalidElementId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                InvalidElementId(ref __self_0_0) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "InvalidElementId");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    #[error("Invalid actor ID: {0}")]
    pub struct InvalidActorId(pub String);
    #[allow(unused_qualifications)]
    impl std::error::Error for InvalidActorId {}
    #[allow(unused_qualifications)]
    impl std::fmt::Display for InvalidActorId {
        #[allow(clippy::used_underscore_binding)]
        fn fmt(&self, __formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
            #[allow(unused_imports)]
            use thiserror::private::{DisplayAsDisplay, PathAsDisplay};
            #[allow(unused_variables, deprecated)]
            let Self(_0) = self;
            __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                &["Invalid actor ID: "],
                &match (&_0.as_display(),) {
                    (arg0,) => [::core::fmt::ArgumentV1::new(
                        arg0,
                        ::core::fmt::Display::fmt,
                    )],
                },
            ))
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for InvalidActorId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                InvalidActorId(ref __self_0_0) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "InvalidActorId");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    #[error("Invalid change hash slice: {0:?}")]
    pub struct InvalidChangeHashSlice(pub Vec<u8>);
    #[allow(unused_qualifications)]
    impl std::error::Error for InvalidChangeHashSlice {}
    #[allow(unused_qualifications)]
    impl std::fmt::Display for InvalidChangeHashSlice {
        #[allow(clippy::used_underscore_binding)]
        fn fmt(&self, __formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
            #[allow(unused_variables, deprecated)]
            let Self(_0) = self;
            __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                &["Invalid change hash slice: "],
                &match (&_0,) {
                    (arg0,) => [::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Debug::fmt)],
                },
            ))
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for InvalidChangeHashSlice {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                InvalidChangeHashSlice(ref __self_0_0) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "InvalidChangeHashSlice");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for InvalidChangeHashSlice {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for InvalidChangeHashSlice {
        #[inline]
        fn eq(&self, other: &InvalidChangeHashSlice) -> bool {
            match *other {
                InvalidChangeHashSlice(ref __self_1_0) => match *self {
                    InvalidChangeHashSlice(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &InvalidChangeHashSlice) -> bool {
            match *other {
                InvalidChangeHashSlice(ref __self_1_0) => match *self {
                    InvalidChangeHashSlice(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[error("Invalid scalar value, expected {expected} but received {unexpected}")]
    pub struct InvalidScalarValue {
        pub raw_value: ScalarValue,
        pub datatype: DataType,
        pub unexpected: String,
        pub expected: String,
    }
    #[allow(unused_qualifications)]
    impl std::error::Error for InvalidScalarValue {}
    #[allow(unused_qualifications)]
    impl std::fmt::Display for InvalidScalarValue {
        #[allow(clippy::used_underscore_binding)]
        fn fmt(&self, __formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
            #[allow(unused_imports)]
            use thiserror::private::{DisplayAsDisplay, PathAsDisplay};
            #[allow(unused_variables, deprecated)]
            let Self {
                raw_value,
                datatype,
                unexpected,
                expected,
            } = self;
            __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                &["Invalid scalar value, expected ", " but received "],
                &match (&expected.as_display(), &unexpected.as_display()) {
                    (arg0, arg1) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                    ],
                },
            ))
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for InvalidScalarValue {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                InvalidScalarValue {
                    raw_value: ref __self_0_0,
                    datatype: ref __self_0_1,
                    unexpected: ref __self_0_2,
                    expected: ref __self_0_3,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "InvalidScalarValue");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "raw_value",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "datatype",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "unexpected",
                        &&(*__self_0_2),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "expected",
                        &&(*__self_0_3),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for InvalidScalarValue {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for InvalidScalarValue {
        #[inline]
        fn eq(&self, other: &InvalidScalarValue) -> bool {
            match *other {
                InvalidScalarValue {
                    raw_value: ref __self_1_0,
                    datatype: ref __self_1_1,
                    unexpected: ref __self_1_2,
                    expected: ref __self_1_3,
                } => match *self {
                    InvalidScalarValue {
                        raw_value: ref __self_0_0,
                        datatype: ref __self_0_1,
                        unexpected: ref __self_0_2,
                        expected: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &InvalidScalarValue) -> bool {
            match *other {
                InvalidScalarValue {
                    raw_value: ref __self_1_0,
                    datatype: ref __self_1_1,
                    unexpected: ref __self_1_2,
                    expected: ref __self_1_3,
                } => match *self {
                    InvalidScalarValue {
                        raw_value: ref __self_0_0,
                        datatype: ref __self_0_1,
                        unexpected: ref __self_0_2,
                        expected: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    pub enum InvalidScalarValues {
        #[error("No scalar values")]
        Empty,
        #[error("Expected kind: `{0}` but got kind: `{1}`")]
        UnexpectedKind(ScalarValueKind, ScalarValueKind),
    }
    #[allow(unused_qualifications)]
    impl std::error::Error for InvalidScalarValues {}
    #[allow(unused_qualifications)]
    impl std::fmt::Display for InvalidScalarValues {
        fn fmt(&self, __formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
            #[allow(unused_imports)]
            use thiserror::private::{DisplayAsDisplay, PathAsDisplay};
            #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
            match self {
                InvalidScalarValues::Empty {} => {
                    __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &["No scalar values"],
                        &match () {
                            () => [],
                        },
                    ))
                }
                InvalidScalarValues::UnexpectedKind(_0, _1) => {
                    __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Expected kind: `", "` but got kind: `", "`"],
                        &match (&_0.as_display(), &_1.as_display()) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ],
                        },
                    ))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for InvalidScalarValues {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&InvalidScalarValues::Empty,) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Empty");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&InvalidScalarValues::UnexpectedKind(ref __self_0, ref __self_1),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "UnexpectedKind");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_1));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for InvalidScalarValues {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for InvalidScalarValues {
        #[inline]
        fn eq(&self, other: &InvalidScalarValues) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &InvalidScalarValues::UnexpectedKind(ref __self_0, ref __self_1),
                            &InvalidScalarValues::UnexpectedKind(ref __arg_1_0, ref __arg_1_1),
                        ) => (*__self_0) == (*__arg_1_0) && (*__self_1) == (*__arg_1_1),
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &InvalidScalarValues) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &InvalidScalarValues::UnexpectedKind(ref __self_0, ref __self_1),
                            &InvalidScalarValues::UnexpectedKind(ref __arg_1_0, ref __arg_1_1),
                        ) => (*__self_0) != (*__arg_1_0) || (*__self_1) != (*__arg_1_1),
                        _ => false,
                    }
                } else {
                    true
                }
            }
        }
    }
}
mod serde_impls {
    use serde::{
        de::{Error, MapAccess},
        Deserialize,
    };
    mod actor_id {
        use std::str::FromStr;
        use serde::{de, Deserialize, Deserializer, Serialize, Serializer};
        use crate::ActorId;
        impl<'de> Deserialize<'de> for ActorId {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: Deserializer<'de>,
            {
                let s = String::deserialize(deserializer)?;
                ActorId::from_str(&s).map_err(|_| {
                    de::Error::invalid_value(de::Unexpected::Str(&s), &"A valid ActorID")
                })
            }
        }
        impl Serialize for ActorId {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: Serializer,
            {
                serializer.serialize_str(self.to_hex_string().as_str())
            }
        }
    }
    mod change_hash {
        use std::convert::TryInto;
        use serde::{de, Deserialize, Deserializer, Serialize, Serializer};
        use crate::ChangeHash;
        impl Serialize for ChangeHash {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: Serializer,
            {
                hex::encode(&self.0).serialize(serializer)
            }
        }
        impl<'de> Deserialize<'de> for ChangeHash {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: Deserializer<'de>,
            {
                let s = String::deserialize(deserializer)?;
                let vec = hex::decode(&s).map_err(|_| {
                    de::Error::invalid_value(de::Unexpected::Str(&s), &"A valid hex string")
                })?;
                vec.as_slice().try_into().map_err(|_| {
                    de::Error::invalid_value(
                        de::Unexpected::Str(&s),
                        &"A 32 byte hex encoded string",
                    )
                })
            }
        }
    }
    mod cursor_diff {
        use serde::{ser::SerializeStruct, Serialize, Serializer};
        use crate::CursorDiff;
        impl Serialize for CursorDiff {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: Serializer,
            {
                let mut map = serializer.serialize_struct("CursorDiff", 4)?;
                map.serialize_field("refObjectId", &self.object_id)?;
                map.serialize_field("elemId", &self.elem_id)?;
                map.serialize_field("index", &self.index)?;
                map.serialize_field("datatype", "cursor")?;
                map.end()
            }
        }
    }
    mod diff {
        use std::{collections::HashMap, fmt};
        use serde::{
            de,
            de::{Error, MapAccess},
            ser::SerializeStruct,
            Deserialize, Deserializer, Serialize, Serializer,
        };
        use super::read_field;
        use crate::{
            CursorDiff, DataType, Diff, DiffEdit, MapDiff, ObjType, ObjectId, OpId, ScalarValue,
            SeqDiff,
        };
        impl Serialize for Diff {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: Serializer,
            {
                match self {
                    Diff::Map(diff) => diff.serialize(serializer),
                    Diff::Seq(diff) => diff.serialize(serializer),
                    Diff::Value(val) => match val {
                        ScalarValue::Counter(_) => {
                            let mut op = serializer.serialize_struct("Value", 3)?;
                            op.serialize_field("value", &val)?;
                            op.serialize_field("datatype", "counter")?;
                            op.serialize_field("type", "value")?;
                            op.end()
                        }
                        ScalarValue::Timestamp(_) => {
                            let mut op = serializer.serialize_struct("Value", 3)?;
                            op.serialize_field("value", &val)?;
                            op.serialize_field("datatype", "timestamp")?;
                            op.serialize_field("type", "value")?;
                            op.end()
                        }
                        ScalarValue::Int(_) => {
                            let mut op = serializer.serialize_struct("Value", 3)?;
                            op.serialize_field("value", &val)?;
                            op.serialize_field("type", "value")?;
                            op.serialize_field("datatype", "int")?;
                            op.end()
                        }
                        ScalarValue::Uint(_) => {
                            let mut op = serializer.serialize_struct("Value", 3)?;
                            op.serialize_field("value", &val)?;
                            op.serialize_field("type", "value")?;
                            op.serialize_field("datatype", "uint")?;
                            op.end()
                        }
                        ScalarValue::F64(_) => {
                            let mut op = serializer.serialize_struct("Value", 3)?;
                            op.serialize_field("value", &val)?;
                            op.serialize_field("type", "value")?;
                            op.serialize_field("datatype", "float64")?;
                            op.end()
                        }
                        _ => {
                            let mut op = serializer.serialize_struct("Value", 2)?;
                            op.serialize_field("value", &val)?;
                            op.serialize_field("type", "value")?;
                            op.end()
                        }
                    },
                    Diff::Cursor(diff) => diff.serialize(serializer),
                }
            }
        }
        enum RawDiffType {
            Value,
            Map,
            Text,
            List,
            Table,
        }
        impl<'de> Deserialize<'de> for RawDiffType {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: Deserializer<'de>,
            {
                const VARIANTS: &[&str] = &["value", "map", "text", "list", "table"];
                let raw_type = String::deserialize(deserializer)?;
                match raw_type.as_str() {
                    "value" => Ok(RawDiffType::Value),
                    "map" => Ok(RawDiffType::Map),
                    "text" => Ok(RawDiffType::Text),
                    "list" => Ok(RawDiffType::List),
                    "table" => Ok(RawDiffType::Table),
                    other => Err(Error::unknown_variant(other, VARIANTS)),
                }
            }
        }
        impl RawDiffType {
            fn obj_type(&self) -> Option<ObjType> {
                match self {
                    RawDiffType::Map => Some(ObjType::map()),
                    RawDiffType::Table => Some(ObjType::table()),
                    RawDiffType::List => Some(ObjType::list()),
                    RawDiffType::Text => Some(ObjType::text()),
                    RawDiffType::Value => None,
                }
            }
        }
        impl<'de> Deserialize<'de> for Diff {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: Deserializer<'de>,
            {
                struct DiffVisitor;
                const FIELDS: &[&str] = &[
                    "edits",
                    "objType",
                    "objectId",
                    "props",
                    "value",
                    "datatype",
                    "refObjectId",
                    "elemId",
                    "index",
                ];
                impl<'de> de::Visitor<'de> for DiffVisitor {
                    type Value = Diff;
                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                        formatter.write_str("A diff")
                    }
                    fn visit_map<V>(self, mut map: V) -> Result<Self::Value, V::Error>
                    where
                        V: MapAccess<'de>,
                    {
                        let mut edits: Option<Vec<DiffEdit>> = None;
                        let mut object_id: Option<ObjectId> = None;
                        let mut diff_type: Option<RawDiffType> = None;
                        let mut props: Option<HashMap<String, HashMap<OpId, Diff>>> = None;
                        let mut value: Option<ScalarValue> = None;
                        let mut datatype: Option<DataType> = None;
                        let mut elem_id: Option<OpId> = None;
                        let mut index: Option<u32> = None;
                        let mut ref_object_id: Option<ObjectId> = None;
                        while let Some(field) = map.next_key::<String>()? {
                            match field.as_ref() {
                                "edits" => read_field("edits", &mut edits, &mut map)?,
                                "objectId" => read_field("objectId", &mut object_id, &mut map)?,
                                "type" => read_field("type", &mut diff_type, &mut map)?,
                                "props" => read_field("props", &mut props, &mut map)?,
                                "value" => read_field("value", &mut value, &mut map)?,
                                "datatype" => read_field("datatype", &mut datatype, &mut map)?,
                                "refObjectId" => {
                                    read_field("refObjectId", &mut ref_object_id, &mut map)?
                                }
                                "elemId" => read_field("elemId", &mut elem_id, &mut map)?,
                                "index" => read_field("index", &mut index, &mut map)?,
                                _ => return Err(Error::unknown_field(&field, FIELDS)),
                            }
                        }
                        if value.is_some() || datatype.is_some() {
                            let datatype = datatype.unwrap_or(DataType::Undefined);
                            match datatype {
                                DataType::Cursor => {
                                    let ref_object_id = ref_object_id
                                        .ok_or_else(|| Error::missing_field("refObjectId"))?;
                                    let elem_id =
                                        elem_id.ok_or_else(|| Error::missing_field("elemId"))?;
                                    let index =
                                        index.ok_or_else(|| Error::missing_field("index"))?;
                                    Ok(Diff::Cursor(CursorDiff {
                                        object_id: ref_object_id,
                                        elem_id,
                                        index,
                                    }))
                                }
                                _ => {
                                    let value =
                                        value.ok_or_else(|| Error::missing_field("value"))?;
                                    let value_with_datatype =
                                        maybe_add_datatype_to_value(value, datatype);
                                    Ok(Diff::Value(value_with_datatype))
                                }
                            }
                        } else {
                            let object_id =
                                object_id.ok_or_else(|| Error::missing_field("objectId"))?;
                            let diff_type =
                                diff_type.ok_or_else(|| Error::missing_field("type"))?;
                            match diff_type . obj_type () { Some (obj_type) => match obj_type { ObjType :: Sequence (seq_type) => { let edits = edits . ok_or_else (| | Error :: missing_field ("edits")) ? ; Ok (Diff :: Seq (SeqDiff { object_id , obj_type : seq_type , edits , })) } ObjType :: Map (map_type) => { let props = props . ok_or_else (| | Error :: missing_field ("props")) ? ; Ok (Diff :: Map (MapDiff { object_id , obj_type : map_type , props , })) } } , None => Err (Error :: custom ("'type' field must be one of ['list', 'text', 'table', 'map'] for an object diff")) , }
                        }
                    }
                }
                deserializer.deserialize_struct("Diff", &FIELDS, DiffVisitor)
            }
        }
        fn maybe_add_datatype_to_value(value: ScalarValue, datatype: DataType) -> ScalarValue {
            match datatype {
                DataType::Counter => {
                    if let Some(n) = value.to_i64() {
                        ScalarValue::Counter(n)
                    } else {
                        value
                    }
                }
                DataType::Timestamp => {
                    if let Some(n) = value.to_i64() {
                        ScalarValue::Timestamp(n)
                    } else {
                        value
                    }
                }
                _ => value,
            }
        }
    }
    mod element_id {
        use std::str::FromStr;
        use serde::{de, Deserialize, Deserializer, Serialize, Serializer};
        use crate::ElementId;
        impl Serialize for ElementId {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: Serializer,
            {
                match self {
                    ElementId::Id(id) => id.serialize(serializer),
                    ElementId::Head => serializer.serialize_str("_head"),
                }
            }
        }
        impl<'de> Deserialize<'de> for ElementId {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: Deserializer<'de>,
            {
                let s = String::deserialize(deserializer)?;
                ElementId::from_str(&s).map_err(|_| de::Error::custom("invalid element ID"))
            }
        }
    }
    mod key {
        use std::str::FromStr;
        use serde::{Deserialize, Deserializer};
        use crate::{ElementId, Key};
        impl<'de> Deserialize<'de> for Key {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: Deserializer<'de>,
            {
                let s = String::deserialize(deserializer)?;
                if let Ok(eid) = ElementId::from_str(&s) {
                    Ok(Key::Seq(eid))
                } else {
                    Ok(Key::Map(s))
                }
            }
        }
    }
    mod multi_element_insert {
        use std::convert::TryInto;
        use crate::{
            DataType, ElementId, MultiElementInsert, ScalarValue, ScalarValues,
            serde_impls::read_field,
        };
        use serde::{
            de::{Error, MapAccess, Unexpected, Visitor},
            ser::{SerializeStruct, Serializer},
            Deserialize, Serialize,
        };
        impl Serialize for MultiElementInsert {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: Serializer,
            {
                let datatype = self.values.as_numerical_datatype();
                let mut ss =
                    serializer.serialize_struct("MultiElementInsert", datatype.map_or(4, |_| 5))?;
                ss.serialize_field("index", &self.index)?;
                ss.serialize_field("elemId", &self.elem_id)?;
                if let Some(datatype) = datatype {
                    ss.serialize_field("datatype", &datatype)?;
                }
                ss.serialize_field("values", &self.values.vec)?;
                ss.end()
            }
        }
        impl<'de> Deserialize<'de> for MultiElementInsert {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                const FIELDS: &[&str] = &["index", "elem_id", "datatype", "values"];
                struct MultiElementInsertVisitor;
                impl<'de> Visitor<'de> for MultiElementInsertVisitor {
                    type Value = MultiElementInsert;
                    fn visit_map<V>(self, mut map: V) -> Result<MultiElementInsert, V::Error>
                    where
                        V: MapAccess<'de>,
                    {
                        let mut index: Option<u64> = None;
                        let mut elem_id: Option<ElementId> = None;
                        let mut datatype: Option<DataType> = None;
                        let mut values: Option<Vec<ScalarValue>> = None;
                        while let Some(field) = map.next_key::<String>()? {
                            match field.as_ref() {
                                "index" => read_field("index", &mut index, &mut map)?,
                                "elemId" => read_field("elemId", &mut elem_id, &mut map)?,
                                "datatype" => read_field("datatype", &mut datatype, &mut map)?,
                                "values" => read_field("values", &mut values, &mut map)?,
                                _ => return Err(Error::unknown_field(&field, FIELDS)),
                            }
                        }
                        let index = index.ok_or_else(|| Error::missing_field("index"))?;
                        let elem_id = elem_id.ok_or_else(|| Error::missing_field("elemId"))?;
                        let mut values = values.ok_or_else(|| Error::missing_field("values"))?;
                        let values = ScalarValues::from_values_and_datatype::<V>(values, datatype)?;
                        Ok(MultiElementInsert {
                            index,
                            elem_id,
                            values,
                        })
                    }
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("A MultiElementInsert")
                    }
                }
                Ok(MultiElementInsert {
                    index: 0,
                    elem_id: crate::ElementId::Head,
                    values: <[_]>::into_vec(box [ScalarValue::Str("one".into())])
                        .try_into()
                        .unwrap(),
                })
            }
        }
    }
    mod object_id {
        use std::str::FromStr;
        use serde::{de, Deserialize, Deserializer, Serialize, Serializer};
        use crate::{ObjectId, OpId};
        impl Serialize for ObjectId {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: Serializer,
            {
                match self {
                    ObjectId::Id(id) => id.serialize(serializer),
                    ObjectId::Root => serializer.serialize_str("_root"),
                }
            }
        }
        impl<'de> Deserialize<'de> for ObjectId {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: Deserializer<'de>,
            {
                let s = String::deserialize(deserializer)?;
                if s == "_root" {
                    Ok(ObjectId::Root)
                } else if let Ok(id) = OpId::from_str(&s) {
                    Ok(ObjectId::Id(id))
                } else {
                    Err(de::Error::invalid_value(
                        de::Unexpected::Str(&s),
                        &"A valid ObjectID",
                    ))
                }
            }
        }
    }
    mod op {
        use std::{convert::TryInto, num::NonZeroU32};
        use serde::{
            de::{Error, MapAccess, Unexpected, Visitor},
            ser::SerializeStruct,
            Deserialize, Deserializer, Serialize, Serializer,
        };
        use super::read_field;
        use crate::{
            DataType, Key, MapType, ObjType, ObjectId, Op, OpId, OpType, ScalarValue, ScalarValues,
            SequenceType, error::InvalidMultiSetValues,
        };
        impl Serialize for Op {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: Serializer,
            {
                let mut fields = 4;
                if self.insert {
                    fields += 1
                }
                let numerical_datatype = match &self.action {
                    OpType::Set(value) => value.as_numerical_datatype(),
                    OpType::MultiSet(values) => values.as_numerical_datatype(),
                    _ => None,
                };
                if numerical_datatype.is_some() {
                    fields += 2
                } else if !match &self.action {
                    OpType::Make(..) => true,
                    _ => false,
                } {
                    fields += 1
                };
                let mut op = serializer.serialize_struct("Operation", fields)?;
                op.serialize_field("action", &self.action)?;
                op.serialize_field("obj", &self.obj)?;
                op.serialize_field(
                    if self.key.is_map_key() {
                        "key"
                    } else {
                        "elemId"
                    },
                    &self.key,
                )?;
                if self.insert {
                    op.serialize_field("insert", &self.insert)?;
                }
                if let Some(datatype) = numerical_datatype {
                    op.serialize_field("datatype", &datatype)?;
                }
                match &self.action {
                    OpType::Inc(n) => op.serialize_field("value", &n)?,
                    OpType::Set(value) => op.serialize_field("value", &value)?,
                    OpType::MultiSet(values) => op.serialize_field("values", &values.vec)?,
                    OpType::Del(multi_op) => op.serialize_field("multiOp", &multi_op)?,
                    OpType::Make(..) => {}
                }
                op.serialize_field("pred", &self.pred)?;
                op.end()
            }
        }
        pub enum RawOpType {
            MakeMap,
            MakeTable,
            MakeList,
            MakeText,
            Del,
            Inc,
            Set,
        }
        impl ::core::marker::StructuralPartialEq for RawOpType {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for RawOpType {
            #[inline]
            fn eq(&self, other: &RawOpType) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for RawOpType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&RawOpType::MakeMap,) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "MakeMap");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                    (&RawOpType::MakeTable,) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "MakeTable");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                    (&RawOpType::MakeList,) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "MakeList");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                    (&RawOpType::MakeText,) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "MakeText");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                    (&RawOpType::Del,) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "Del");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                    (&RawOpType::Inc,) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "Inc");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                    (&RawOpType::Set,) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "Set");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for RawOpType {
            #[inline]
            fn clone(&self) -> RawOpType {
                {
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for RawOpType {}
        impl Serialize for RawOpType {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: Serializer,
            {
                let s = match self {
                    RawOpType::MakeMap => "makeMap",
                    RawOpType::MakeTable => "makeTable",
                    RawOpType::MakeList => "makeList",
                    RawOpType::MakeText => "makeText",
                    RawOpType::Del => "del",
                    RawOpType::Inc => "inc",
                    RawOpType::Set => "set",
                };
                serializer.serialize_str(s)
            }
        }
        impl<'de> Deserialize<'de> for RawOpType {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: Deserializer<'de>,
            {
                const VARIANTS: &[&str] = &[
                    "makeMap",
                    "makeTable",
                    "makeList",
                    "makeText",
                    "del",
                    "inc",
                    "set",
                ];
                let raw_type = String::deserialize(deserializer)?;
                match raw_type.as_str() {
                    "makeMap" => Ok(RawOpType::MakeMap),
                    "makeTable" => Ok(RawOpType::MakeTable),
                    "makeList" => Ok(RawOpType::MakeList),
                    "makeText" => Ok(RawOpType::MakeText),
                    "del" => Ok(RawOpType::Del),
                    "inc" => Ok(RawOpType::Inc),
                    "set" => Ok(RawOpType::Set),
                    other => Err(Error::unknown_variant(other, VARIANTS)),
                }
            }
        }
        impl<'de> Deserialize<'de> for Op {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: Deserializer<'de>,
            {
                const FIELDS: &[&str] = &["ops", "deps", "message", "seq", "actor", "requestType"];
                struct OperationVisitor;
                impl<'de> Visitor<'de> for OperationVisitor {
                    type Value = Op;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("An operation object")
                    }
                    fn visit_map<V>(self, mut map: V) -> Result<Op, V::Error>
                    where
                        V: MapAccess<'de>,
                    {
                        let mut action: Option<RawOpType> = None;
                        let mut obj: Option<ObjectId> = None;
                        let mut key: Option<Key> = None;
                        let mut pred: Option<Vec<OpId>> = None;
                        let mut insert: Option<bool> = None;
                        let mut datatype: Option<DataType> = None;
                        let mut value: Option<Option<ScalarValue>> = None;
                        let mut ref_id: Option<OpId> = None;
                        let mut values: Option<Vec<ScalarValue>> = None;
                        let mut multi_op: Option<u32> = None;
                        while let Some(field) = map.next_key::<String>()? {
                            match field.as_ref() {
                                "action" => read_field("action", &mut action, &mut map)?,
                                "obj" => read_field("obj", &mut obj, &mut map)?,
                                "key" => read_field("key", &mut key, &mut map)?,
                                "elemId" => read_field("elemId", &mut key, &mut map)?,
                                "pred" => read_field("pred", &mut pred, &mut map)?,
                                "insert" => read_field("insert", &mut insert, &mut map)?,
                                "datatype" => read_field("datatype", &mut datatype, &mut map)?,
                                "value" => read_field("value", &mut value, &mut map)?,
                                "ref" => read_field("ref", &mut ref_id, &mut map)?,
                                "values" => read_field("values", &mut values, &mut map)?,
                                "multiOp" => read_field("multiOp", &mut multi_op, &mut map)?,
                                _ => return Err(Error::unknown_field(&field, FIELDS)),
                            }
                        }
                        let action = action.ok_or_else(|| Error::missing_field("action"))?;
                        let obj = obj.ok_or_else(|| Error::missing_field("obj"))?;
                        let key = key.ok_or_else(|| Error::missing_field("key"))?;
                        let pred = pred.ok_or_else(|| Error::missing_field("pred"))?;
                        let insert = insert.unwrap_or(false);
                        let action = match action {
                            RawOpType::MakeMap => OpType::Make(ObjType::Map(MapType::Map)),
                            RawOpType::MakeTable => OpType::Make(ObjType::Map(MapType::Table)),
                            RawOpType::MakeList => {
                                OpType::Make(ObjType::Sequence(SequenceType::List))
                            }
                            RawOpType::MakeText => {
                                OpType::Make(ObjType::Sequence(SequenceType::Text))
                            }
                            RawOpType::Del => OpType::Del(
                                multi_op
                                    .map(|i| NonZeroU32::new(i).unwrap())
                                    .unwrap_or_else(|| NonZeroU32::new(1).unwrap()),
                            ),
                            RawOpType::Set => {
                                if let Some(mut values) = values {
                                    let values = ScalarValues::from_values_and_datatype::<V>(
                                        values, datatype,
                                    )?;
                                    OpType::MultiSet(values)
                                } else {
                                    let value = if let Some(datatype) = datatype {
                                        match datatype {
                                            DataType::Cursor => match ref_id {
                                                Some(opid) => ScalarValue::Cursor(opid),
                                                None => return Err(Error::missing_field("ref")),
                                            },
                                            _ => {
                                                let raw_value = value
                                                    .ok_or_else(|| Error::missing_field("value"))?
                                                    .unwrap_or(ScalarValue::Null);
                                                raw_value.as_datatype(datatype).map_err(|e| {
                                                    Error::invalid_value(
                                                        Unexpected::Other(e.unexpected.as_str()),
                                                        &e.expected.as_str(),
                                                    )
                                                })?
                                            }
                                        }
                                    } else {
                                        value
                                            .ok_or_else(|| Error::missing_field("value"))?
                                            .unwrap_or(ScalarValue::Null)
                                    };
                                    OpType::Set(value)
                                }
                            }
                            RawOpType::Inc => match value.flatten() {
                                Some(ScalarValue::Int(n)) => Ok(OpType::Inc(n)),
                                Some(ScalarValue::Uint(n)) => Ok(OpType::Inc(n as i64)),
                                Some(ScalarValue::F64(n)) => Ok(OpType::Inc(n as i64)),
                                Some(ScalarValue::Counter(n)) => Ok(OpType::Inc(n)),
                                Some(ScalarValue::Timestamp(n)) => Ok(OpType::Inc(n)),
                                Some(ScalarValue::Bytes(s)) => {
                                    Err(Error::invalid_value(Unexpected::Bytes(&s), &"a number"))
                                }
                                Some(ScalarValue::Str(s)) => {
                                    Err(Error::invalid_value(Unexpected::Str(&s), &"a number"))
                                }
                                Some(ScalarValue::Boolean(b)) => {
                                    Err(Error::invalid_value(Unexpected::Bool(b), &"a number"))
                                }
                                Some(ScalarValue::Null) => Err(Error::invalid_value(
                                    Unexpected::Other("null"),
                                    &"a number",
                                )),
                                Some(ScalarValue::Cursor(..)) => Err(Error::invalid_value(
                                    Unexpected::Other("a cursor"),
                                    &"a number",
                                )),
                                None => Err(Error::missing_field("value")),
                            }?,
                        };
                        Ok(Op {
                            action,
                            obj,
                            key,
                            pred,
                            insert,
                        })
                    }
                }
                deserializer.deserialize_struct("Operation", &FIELDS, OperationVisitor)
            }
        }
    }
    mod op_type {
        use serde::{Serialize, Serializer};
        use super::op::RawOpType;
        use crate::{MapType, ObjType, OpType, SequenceType};
        impl Serialize for OpType {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: Serializer,
            {
                let raw_type = match self {
                    OpType::Make(ObjType::Map(MapType::Map)) => RawOpType::MakeMap,
                    OpType::Make(ObjType::Map(MapType::Table)) => RawOpType::MakeTable,
                    OpType::Make(ObjType::Sequence(SequenceType::List)) => RawOpType::MakeList,
                    OpType::Make(ObjType::Sequence(SequenceType::Text)) => RawOpType::MakeText,
                    OpType::Del(..) => RawOpType::Del,
                    OpType::Inc(_) => RawOpType::Inc,
                    OpType::Set(_) => RawOpType::Set,
                    OpType::MultiSet(..) => RawOpType::Set,
                };
                raw_type.serialize(serializer)
            }
        }
    }
    mod opid {
        use std::str::FromStr;
        use serde::{de, Deserialize, Deserializer, Serialize, Serializer};
        use crate::OpId;
        impl<'de> Deserialize<'de> for OpId {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: Deserializer<'de>,
            {
                let s = String::deserialize(deserializer)?;
                OpId::from_str(&s)
                    .map_err(|_| de::Error::invalid_value(de::Unexpected::Str(&s), &"A valid OpID"))
            }
        }
        impl Serialize for OpId {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: Serializer,
            {
                serializer.serialize_str(self.to_string().as_str())
            }
        }
    }
    mod root_diff {
        use std::fmt;
        use serde::{
            de,
            de::{MapAccess, Unexpected, Visitor},
            ser::SerializeMap,
            Deserialize, Deserializer, Serialize, Serializer,
        };
        use crate::{MapType, ObjectId, RootDiff};
        impl Serialize for RootDiff {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: Serializer,
            {
                let mut map = serializer.serialize_map(Some(3))?;
                map.serialize_entry("objectId", &ObjectId::Root)?;
                map.serialize_entry("type", &MapType::Map)?;
                map.serialize_entry("props", &self.props)?;
                map.end()
            }
        }
        impl<'de> Deserialize<'de> for RootDiff {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: Deserializer<'de>,
            {
                #[serde(field_identifier, rename_all = "camelCase")]
                enum Field {
                    ObjectId,
                    #[serde(rename = "type")]
                    ObjectType,
                    Props,
                }
                #[doc(hidden)]
                #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
                const _: () = {
                    #[allow(rust_2018_idioms, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for Field {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            const FIELDS: &'static [&'static str] = &["objectId", "type", "props"];
                            struct __FieldVisitor<'de> {
                                marker: _serde::__private::PhantomData<Field>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor<'de> {
                                type Value = Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result
                                {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(Field::ObjectId),
                                        1u64 => _serde::__private::Ok(Field::ObjectType),
                                        2u64 => _serde::__private::Ok(Field::Props),
                                        _ => _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"field index 0 <= i < 3",
                                            ),
                                        ),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "objectId" => _serde::__private::Ok(Field::ObjectId),
                                        "type" => _serde::__private::Ok(Field::ObjectType),
                                        "props" => _serde::__private::Ok(Field::Props),
                                        _ => _serde::__private::Err(
                                            _serde::de::Error::unknown_field(__value, FIELDS),
                                        ),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"objectId" => _serde::__private::Ok(Field::ObjectId),
                                        b"type" => _serde::__private::Ok(Field::ObjectType),
                                        b"props" => _serde::__private::Ok(Field::Props),
                                        _ => {
                                            let __value =
                                                &_serde::__private::from_utf8_lossy(__value);
                                            _serde::__private::Err(
                                                _serde::de::Error::unknown_field(__value, FIELDS),
                                            )
                                        }
                                    }
                                }
                            }
                            let __visitor = __FieldVisitor {
                                marker: _serde::__private::PhantomData::<Field>,
                                lifetime: _serde::__private::PhantomData,
                            };
                            _serde::Deserializer::deserialize_identifier(__deserializer, __visitor)
                        }
                    }
                };
                struct RootDiffVisitor;
                const FIELDS: &[&str] = &["objectId", "type", "props"];
                impl<'de> Visitor<'de> for RootDiffVisitor {
                    type Value = RootDiff;
                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                        formatter.write_str("struct RootDiff")
                    }
                    fn visit_map<V>(self, mut map: V) -> Result<Self::Value, V::Error>
                    where
                        V: MapAccess<'de>,
                    {
                        let mut object_id = None;
                        let mut object_type = None;
                        let mut props = None;
                        while let Some(key) = map.next_key()? {
                            match key {
                                Field::ObjectId => {
                                    if object_id.is_some() {
                                        return Err(de::Error::duplicate_field("objectId"));
                                    }
                                    object_id = Some(map.next_value()?);
                                }
                                Field::ObjectType => {
                                    if object_type.is_some() {
                                        return Err(de::Error::duplicate_field("type"));
                                    }
                                    object_type = Some(map.next_value()?)
                                }
                                Field::Props => {
                                    if props.is_some() {
                                        return Err(de::Error::duplicate_field("props"));
                                    }
                                    props = Some(map.next_value()?)
                                }
                            }
                        }
                        let object_id: ObjectId =
                            object_id.ok_or_else(|| de::Error::missing_field("objectId"))?;
                        let object_type: MapType =
                            object_type.ok_or_else(|| de::Error::missing_field("type"))?;
                        let props = props.ok_or_else(|| de::Error::missing_field("props"))?;
                        if let ObjectId::Id(opid) = object_id {
                            return Err(de::Error::invalid_value(
                                Unexpected::Str(&opid.to_string()),
                                &"_root",
                            ));
                        }
                        if object_type != MapType::Map {
                            return Err(de::Error::invalid_value(Unexpected::Str("table"), &"map"));
                        }
                        Ok(RootDiff { props })
                    }
                }
                deserializer.deserialize_struct("RootDiff", &FIELDS, RootDiffVisitor)
            }
        }
    }
    mod scalar_value {
        use serde::{de, Deserialize, Deserializer};
        use crate::ScalarValue;
        impl<'de> Deserialize<'de> for ScalarValue {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: Deserializer<'de>,
            {
                struct ValueVisitor;
                impl<'de> de::Visitor<'de> for ValueVisitor {
                    type Value = ScalarValue;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a number, string, bool, or null")
                    }
                    fn visit_bool<E>(self, value: bool) -> Result<ScalarValue, E>
                    where
                        E: de::Error,
                    {
                        Ok(ScalarValue::Boolean(value))
                    }
                    fn visit_u64<E>(self, value: u64) -> Result<ScalarValue, E>
                    where
                        E: de::Error,
                    {
                        Ok(ScalarValue::Uint(value))
                    }
                    fn visit_i64<E>(self, value: i64) -> Result<ScalarValue, E>
                    where
                        E: de::Error,
                    {
                        Ok(ScalarValue::Int(value))
                    }
                    fn visit_f64<E>(self, value: f64) -> Result<ScalarValue, E>
                    where
                        E: de::Error,
                    {
                        Ok(ScalarValue::F64(value))
                    }
                    fn visit_str<E>(self, value: &str) -> Result<ScalarValue, E>
                    where
                        E: de::Error,
                    {
                        Ok(ScalarValue::Str(value.to_string()))
                    }
                    fn visit_none<E>(self) -> Result<ScalarValue, E>
                    where
                        E: de::Error,
                    {
                        Ok(ScalarValue::Null)
                    }
                }
                deserializer.deserialize_any(ValueVisitor)
            }
        }
    }
    pub(crate) fn read_field<'de, T, M>(
        name: &'static str,
        data: &mut Option<T>,
        map: &mut M,
    ) -> Result<(), M::Error>
    where
        M: MapAccess<'de>,
        T: Deserialize<'de>,
    {
        if data.is_some() {
            Err(Error::duplicate_field(name))
        } else {
            data.replace(map.next_value()?);
            Ok(())
        }
    }
}
mod utility_impls {
    mod actor_id {
        use std::{convert::TryFrom, fmt, str::FromStr};
        use crate::{error::InvalidActorId, ActorId};
        impl TryFrom<&str> for ActorId {
            type Error = InvalidActorId;
            fn try_from(s: &str) -> Result<Self, Self::Error> {
                hex::decode(s)
                    .map(ActorId)
                    .map_err(|_| InvalidActorId(s.into()))
            }
        }
        impl From<&[u8]> for ActorId {
            fn from(b: &[u8]) -> Self {
                ActorId(b.to_vec())
            }
        }
        impl From<Vec<u8>> for ActorId {
            fn from(b: Vec<u8>) -> Self {
                ActorId(b)
            }
        }
        impl FromStr for ActorId {
            type Err = InvalidActorId;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                ActorId::try_from(s)
            }
        }
        impl fmt::Display for ActorId {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &[""],
                    &match (&self.to_hex_string(),) {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                ))
            }
        }
    }
    mod change_hash {
        use std::convert::TryFrom;
        use crate::{error::InvalidChangeHashSlice, ChangeHash};
        impl TryFrom<&[u8]> for ChangeHash {
            type Error = InvalidChangeHashSlice;
            fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {
                if bytes.len() != 32 {
                    Err(InvalidChangeHashSlice(Vec::from(bytes)))
                } else {
                    let mut array = [0; 32];
                    array.copy_from_slice(bytes);
                    Ok(ChangeHash(array))
                }
            }
        }
    }
    mod diff {
        use crate::{Diff, MapDiff, ScalarValue, SeqDiff};
        impl From<MapDiff> for Diff {
            fn from(m: MapDiff) -> Self {
                Diff::Map(m)
            }
        }
        impl From<SeqDiff> for Diff {
            fn from(s: SeqDiff) -> Self {
                Diff::Seq(s)
            }
        }
        impl From<&ScalarValue> for Diff {
            fn from(v: &ScalarValue) -> Self {
                Diff::Value(v.clone())
            }
        }
        impl From<ScalarValue> for Diff {
            fn from(v: ScalarValue) -> Self {
                Diff::Value(v)
            }
        }
        impl From<&str> for Diff {
            fn from(s: &str) -> Self {
                Diff::Value(s.into())
            }
        }
    }
    mod element_id {
        use std::{
            cmp::{Ordering, PartialOrd},
            convert::TryFrom,
            str::FromStr,
        };
        use crate::{error::InvalidElementId, ElementId, OpId};
        impl PartialOrd for ElementId {
            fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
                Some(self.cmp(other))
            }
        }
        impl Ord for ElementId {
            fn cmp(&self, other: &Self) -> Ordering {
                match (self, other) {
                    (ElementId::Id(a), ElementId::Id(b)) => a.cmp(b),
                    (ElementId::Head, ElementId::Head) => Ordering::Equal,
                    (ElementId::Head, _) => Ordering::Less,
                    (_, ElementId::Head) => Ordering::Greater,
                }
            }
        }
        impl From<OpId> for ElementId {
            fn from(o: OpId) -> Self {
                ElementId::Id(o)
            }
        }
        impl From<&OpId> for ElementId {
            fn from(o: &OpId) -> Self {
                ElementId::Id(o.clone())
            }
        }
        impl FromStr for ElementId {
            type Err = InvalidElementId;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    "_head" => Ok(ElementId::Head),
                    id => Ok(ElementId::Id(
                        OpId::from_str(id).map_err(|_| InvalidElementId(id.to_string()))?,
                    )),
                }
            }
        }
        impl TryFrom<&str> for ElementId {
            type Error = InvalidElementId;
            fn try_from(value: &str) -> Result<Self, Self::Error> {
                ElementId::from_str(value)
            }
        }
        impl std::fmt::Display for ElementId {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                match self {
                    ElementId::Head => f.write_fmt(::core::fmt::Arguments::new_v1(
                        &["_head"],
                        &match () {
                            () => [],
                        },
                    )),
                    ElementId::Id(id) => f.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&id.to_string(),) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    )),
                }
            }
        }
    }
    mod key {
        use std::cmp::{Ordering, PartialOrd};
        use crate::{ElementId, Key, OpId};
        impl PartialOrd for Key {
            fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
                Some(self.cmp(other))
            }
        }
        impl Ord for Key {
            fn cmp(&self, other: &Self) -> Ordering {
                match (self, other) {
                    (Key::Map(a), Key::Map(b)) => a.cmp(b),
                    (Key::Seq(a), Key::Seq(b)) => a.cmp(b),
                    (Key::Map(_), _) => Ordering::Less,
                    (_, Key::Map(_)) => Ordering::Greater,
                }
            }
        }
        impl From<OpId> for Key {
            fn from(id: OpId) -> Self {
                Key::Seq(ElementId::Id(id))
            }
        }
        impl From<&OpId> for Key {
            fn from(id: &OpId) -> Self {
                Key::Seq(ElementId::Id(id.clone()))
            }
        }
        impl From<ElementId> for Key {
            fn from(id: ElementId) -> Self {
                Key::Seq(id)
            }
        }
        impl<S> From<S> for Key
        where
            S: AsRef<str>,
        {
            fn from(s: S) -> Self {
                Key::Map(s.as_ref().to_string())
            }
        }
    }
    mod object_id {
        use std::{
            cmp::{Ordering, PartialOrd},
            convert::TryFrom,
            fmt,
            str::FromStr,
        };
        use crate::{error::InvalidObjectId, ObjectId, OpId};
        impl PartialOrd for ObjectId {
            fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
                Some(self.cmp(other))
            }
        }
        impl Ord for ObjectId {
            fn cmp(&self, other: &Self) -> Ordering {
                match (self, other) {
                    (ObjectId::Root, ObjectId::Root) => Ordering::Equal,
                    (ObjectId::Root, _) => Ordering::Less,
                    (_, ObjectId::Root) => Ordering::Greater,
                    (ObjectId::Id(a), ObjectId::Id(b)) => a.cmp(b),
                }
            }
        }
        impl From<&OpId> for ObjectId {
            fn from(o: &OpId) -> Self {
                ObjectId::Id(o.clone())
            }
        }
        impl From<&ObjectId> for ObjectId {
            fn from(o: &ObjectId) -> Self {
                o.clone()
            }
        }
        impl FromStr for ObjectId {
            type Err = InvalidObjectId;
            fn from_str(s: &str) -> Result<ObjectId, Self::Err> {
                if s == "_root" {
                    Ok(ObjectId::Root)
                } else if let Ok(id) = OpId::from_str(s) {
                    Ok(ObjectId::Id(id))
                } else {
                    Err(InvalidObjectId(s.to_string()))
                }
            }
        }
        impl From<OpId> for ObjectId {
            fn from(id: OpId) -> Self {
                ObjectId::Id(id)
            }
        }
        impl fmt::Display for ObjectId {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                match self {
                    ObjectId::Root => f.write_fmt(::core::fmt::Arguments::new_v1(
                        &["_root"],
                        &match () {
                            () => [],
                        },
                    )),
                    ObjectId::Id(oid) => f.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&oid,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    )),
                }
            }
        }
        impl TryFrom<&str> for ObjectId {
            type Error = InvalidObjectId;
            fn try_from(value: &str) -> Result<Self, Self::Error> {
                ObjectId::from_str(value)
            }
        }
    }
    mod opid {
        use core::fmt;
        use std::{
            cmp::{Ordering, PartialOrd},
            convert::TryFrom,
            str::FromStr,
        };
        use crate::{error::InvalidOpId, ActorId, OpId};
        impl Ord for OpId {
            fn cmp(&self, other: &Self) -> Ordering {
                if self.0 != other.0 {
                    self.0.cmp(&other.0)
                } else {
                    self.1.cmp(&other.1)
                }
            }
        }
        impl fmt::Debug for OpId {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.write_str(self.to_string().as_str())
            }
        }
        impl fmt::Display for OpId {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                match self {
                    OpId(seq, actor) => f.write_fmt(::core::fmt::Arguments::new_v1(
                        &["", "@"],
                        &match (&seq, &actor) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ],
                        },
                    )),
                }
            }
        }
        impl PartialOrd for OpId {
            fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
                Some(self.cmp(other))
            }
        }
        impl FromStr for OpId {
            type Err = InvalidOpId;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                let mut i = s.split('@');
                match (i.next(), i.next(), i.next()) {
                    (Some(counter_str), Some(actor_str), None) => {
                        match (counter_str.parse(), ActorId::from_str(actor_str)) {
                            (Ok(counter), Ok(actor)) => Ok(OpId(counter, actor)),
                            _ => Err(InvalidOpId(s.to_string())),
                        }
                    }
                    _ => Err(InvalidOpId(s.to_string())),
                }
            }
        }
        impl TryFrom<&str> for OpId {
            type Error = InvalidOpId;
            fn try_from(s: &str) -> Result<Self, InvalidOpId> {
                OpId::from_str(s)
            }
        }
        impl From<&OpId> for String {
            fn from(id: &OpId) -> Self {
                id.to_string()
            }
        }
    }
    mod scalar_value {
        use std::fmt;
        use crate::ScalarValue;
        impl From<&str> for ScalarValue {
            fn from(s: &str) -> Self {
                ScalarValue::Str(s.into())
            }
        }
        impl From<i64> for ScalarValue {
            fn from(n: i64) -> Self {
                ScalarValue::Int(n)
            }
        }
        impl From<u64> for ScalarValue {
            fn from(n: u64) -> Self {
                ScalarValue::Uint(n)
            }
        }
        impl From<i32> for ScalarValue {
            fn from(n: i32) -> Self {
                ScalarValue::Int(n as i64)
            }
        }
        impl From<bool> for ScalarValue {
            fn from(b: bool) -> Self {
                ScalarValue::Boolean(b)
            }
        }
        impl From<char> for ScalarValue {
            fn from(c: char) -> Self {
                ScalarValue::Str(c.to_string())
            }
        }
        impl fmt::Display for ScalarValue {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                match self {
                    ScalarValue::Bytes(b) => f.write_fmt(::core::fmt::Arguments::new_v1(
                        &["\"", "\""],
                        &match (&b,) {
                            (arg0,) => {
                                [::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Debug::fmt)]
                            }
                        },
                    )),
                    ScalarValue::Str(s) => f.write_fmt(::core::fmt::Arguments::new_v1(
                        &["\"", "\""],
                        &match (&s,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    )),
                    ScalarValue::Int(i) => f.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&i,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    )),
                    ScalarValue::Uint(i) => f.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&i,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    )),
                    ScalarValue::F64(n) => f.write_fmt(::core::fmt::Arguments::new_v1_formatted(
                        &[""],
                        &match (&n,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                        &[::core::fmt::rt::v1::Argument {
                            position: 0usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Is(324usize),
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        }],
                    )),
                    ScalarValue::Counter(c) => f.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Counter: "],
                        &match (&c,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    )),
                    ScalarValue::Timestamp(i) => f.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Timestamp: "],
                        &match (&i,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    )),
                    ScalarValue::Boolean(b) => f.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&b,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    )),
                    ScalarValue::Null => f.write_fmt(::core::fmt::Arguments::new_v1(
                        &["null"],
                        &match () {
                            () => [],
                        },
                    )),
                    ScalarValue::Cursor(elemid) => f.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Cursor: "],
                        &match (&elemid,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    )),
                }
            }
        }
    }
}
use std::{collections::HashMap, convert::TryFrom, fmt, num::NonZeroU32, slice::Iter};
use error::InvalidMultiSetValues;
use serde::{
    de::{Error, MapAccess, Unexpected},
    Deserialize, Serialize,
};
use strum::EnumDiscriminants;
pub struct ActorId(Vec<u8>);
impl ::core::marker::StructuralEq for ActorId {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::Eq for ActorId {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        {
            let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
        }
    }
}
impl ::core::marker::StructuralPartialEq for ActorId {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for ActorId {
    #[inline]
    fn eq(&self, other: &ActorId) -> bool {
        match *other {
            ActorId(ref __self_1_0) => match *self {
                ActorId(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
            },
        }
    }
    #[inline]
    fn ne(&self, other: &ActorId) -> bool {
        match *other {
            ActorId(ref __self_1_0) => match *self {
                ActorId(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
            },
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::hash::Hash for ActorId {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        match *self {
            ActorId(ref __self_0_0) => ::core::hash::Hash::hash(&(*__self_0_0), state),
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for ActorId {
    #[inline]
    fn clone(&self) -> ActorId {
        match *self {
            ActorId(ref __self_0_0) => ActorId(::core::clone::Clone::clone(&(*__self_0_0))),
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialOrd for ActorId {
    #[inline]
    fn partial_cmp(&self, other: &ActorId) -> ::core::option::Option<::core::cmp::Ordering> {
        match *other {
            ActorId(ref __self_1_0) => match *self {
                ActorId(ref __self_0_0) => {
                    match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                        }
                        cmp => cmp,
                    }
                }
            },
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::Ord for ActorId {
    #[inline]
    fn cmp(&self, other: &ActorId) -> ::core::cmp::Ordering {
        match *other {
            ActorId(ref __self_1_0) => match *self {
                ActorId(ref __self_0_0) => {
                    match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                        ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                        cmp => cmp,
                    }
                }
            },
        }
    }
}
impl fmt::Debug for ActorId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_tuple("ActorID")
            .field(&hex::encode(&self.0))
            .finish()
    }
}
impl ActorId {
    pub fn random() -> ActorId {
        ActorId(uuid::Uuid::new_v4().as_bytes().to_vec())
    }
    pub fn to_bytes(&self) -> Vec<u8> {
        self.0.clone()
    }
    pub fn into_bytes(self) -> Vec<u8> {
        self.0
    }
    pub fn from_bytes(bytes: &[u8]) -> ActorId {
        ActorId(bytes.to_vec())
    }
    pub fn to_hex_string(&self) -> String {
        hex::encode(&self.0)
    }
    pub fn op_id_at(&self, seq: u64) -> OpId {
        OpId(seq, self.clone())
    }
}
#[serde(rename_all = "camelCase", untagged)]
pub enum ObjType {
    Map(MapType),
    Sequence(SequenceType),
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for ObjType {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            let __content =
                match <_serde::__private::de::Content as _serde::Deserialize>::deserialize(
                    __deserializer,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <MapType as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                ObjType::Map,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <SequenceType as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                ObjType::Sequence,
            ) {
                return _serde::__private::Ok(__ok);
            }
            _serde::__private::Err(_serde::de::Error::custom(
                "data did not match any variant of untagged enum ObjType",
            ))
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for ObjType {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                ObjType::Map(ref __field0) => _serde::Serialize::serialize(__field0, __serializer),
                ObjType::Sequence(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
            }
        }
    }
};
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for ObjType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match (&*self,) {
            (&ObjType::Map(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Map");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&ObjType::Sequence(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Sequence");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for ObjType {
    #[inline]
    fn clone(&self) -> ObjType {
        {
            let _: ::core::clone::AssertParamIsClone<MapType>;
            let _: ::core::clone::AssertParamIsClone<SequenceType>;
            *self
        }
    }
}
impl ::core::marker::StructuralPartialEq for ObjType {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for ObjType {
    #[inline]
    fn eq(&self, other: &ObjType) -> bool {
        {
            let __self_vi = ::core::intrinsics::discriminant_value(&*self);
            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (&ObjType::Map(ref __self_0), &ObjType::Map(ref __arg_1_0)) => {
                        (*__self_0) == (*__arg_1_0)
                    }
                    (&ObjType::Sequence(ref __self_0), &ObjType::Sequence(ref __arg_1_0)) => {
                        (*__self_0) == (*__arg_1_0)
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() },
                }
            } else {
                false
            }
        }
    }
    #[inline]
    fn ne(&self, other: &ObjType) -> bool {
        {
            let __self_vi = ::core::intrinsics::discriminant_value(&*self);
            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (&ObjType::Map(ref __self_0), &ObjType::Map(ref __arg_1_0)) => {
                        (*__self_0) != (*__arg_1_0)
                    }
                    (&ObjType::Sequence(ref __self_0), &ObjType::Sequence(ref __arg_1_0)) => {
                        (*__self_0) != (*__arg_1_0)
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() },
                }
            } else {
                true
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::marker::Copy for ObjType {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::hash::Hash for ObjType {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        match (&*self,) {
            (&ObjType::Map(ref __self_0),) => {
                ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self), state);
                ::core::hash::Hash::hash(&(*__self_0), state)
            }
            (&ObjType::Sequence(ref __self_0),) => {
                ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self), state);
                ::core::hash::Hash::hash(&(*__self_0), state)
            }
        }
    }
}
impl ObjType {
    pub fn map() -> ObjType {
        ObjType::Map(MapType::Map)
    }
    pub fn table() -> ObjType {
        ObjType::Map(MapType::Table)
    }
    pub fn text() -> ObjType {
        ObjType::Sequence(SequenceType::Text)
    }
    pub fn list() -> ObjType {
        ObjType::Sequence(SequenceType::List)
    }
}
impl fmt::Display for ObjType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ObjType::Map(MapType::Map) => f.write_fmt(::core::fmt::Arguments::new_v1(
                &["map"],
                &match () {
                    () => [],
                },
            )),
            ObjType::Map(MapType::Table) => f.write_fmt(::core::fmt::Arguments::new_v1(
                &["table"],
                &match () {
                    () => [],
                },
            )),
            ObjType::Sequence(SequenceType::List) => f.write_fmt(::core::fmt::Arguments::new_v1(
                &["list"],
                &match () {
                    () => [],
                },
            )),
            ObjType::Sequence(SequenceType::Text) => f.write_fmt(::core::fmt::Arguments::new_v1(
                &["text"],
                &match () {
                    () => [],
                },
            )),
        }
    }
}
#[serde(rename_all = "camelCase")]
pub enum MapType {
    Map,
    Table,
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for MapType {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            enum __Field {
                __field0,
                __field1,
            }
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "variant identifier")
                }
                fn visit_u64<__E>(self, __value: u64) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                            _serde::de::Unexpected::Unsigned(__value),
                            &"variant index 0 <= i < 2",
                        )),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "map" => _serde::__private::Ok(__Field::__field0),
                        "table" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                            __value, VARIANTS,
                        )),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"map" => _serde::__private::Ok(__Field::__field0),
                        b"table" => _serde::__private::Ok(__Field::__field1),
                        _ => {
                            let __value = &_serde::__private::from_utf8_lossy(__value);
                            _serde::__private::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            ))
                        }
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<MapType>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = MapType;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "enum MapType")
                }
                fn visit_enum<__A>(
                    self,
                    __data: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::EnumAccess<'de>,
                {
                    match match _serde::de::EnumAccess::variant(__data) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        (__Field::__field0, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(MapType::Map)
                        }
                        (__Field::__field1, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(MapType::Table)
                        }
                    }
                }
            }
            const VARIANTS: &'static [&'static str] = &["map", "table"];
            _serde::Deserializer::deserialize_enum(
                __deserializer,
                "MapType",
                VARIANTS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<MapType>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for MapType {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                MapType::Map => {
                    _serde::Serializer::serialize_unit_variant(__serializer, "MapType", 0u32, "map")
                }
                MapType::Table => _serde::Serializer::serialize_unit_variant(
                    __serializer,
                    "MapType",
                    1u32,
                    "table",
                ),
            }
        }
    }
};
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for MapType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match (&*self,) {
            (&MapType::Map,) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Map");
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&MapType::Table,) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Table");
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for MapType {
    #[inline]
    fn clone(&self) -> MapType {
        {
            *self
        }
    }
}
impl ::core::marker::StructuralPartialEq for MapType {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for MapType {
    #[inline]
    fn eq(&self, other: &MapType) -> bool {
        {
            let __self_vi = ::core::intrinsics::discriminant_value(&*self);
            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    _ => true,
                }
            } else {
                false
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::marker::Copy for MapType {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::hash::Hash for MapType {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        match (&*self,) {
            _ => ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self), state),
        }
    }
}
#[serde(rename_all = "camelCase")]
pub enum SequenceType {
    List,
    Text,
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for SequenceType {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            enum __Field {
                __field0,
                __field1,
            }
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "variant identifier")
                }
                fn visit_u64<__E>(self, __value: u64) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                            _serde::de::Unexpected::Unsigned(__value),
                            &"variant index 0 <= i < 2",
                        )),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "list" => _serde::__private::Ok(__Field::__field0),
                        "text" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                            __value, VARIANTS,
                        )),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"list" => _serde::__private::Ok(__Field::__field0),
                        b"text" => _serde::__private::Ok(__Field::__field1),
                        _ => {
                            let __value = &_serde::__private::from_utf8_lossy(__value);
                            _serde::__private::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            ))
                        }
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<SequenceType>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = SequenceType;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "enum SequenceType")
                }
                fn visit_enum<__A>(
                    self,
                    __data: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::EnumAccess<'de>,
                {
                    match match _serde::de::EnumAccess::variant(__data) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        (__Field::__field0, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(SequenceType::List)
                        }
                        (__Field::__field1, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(SequenceType::Text)
                        }
                    }
                }
            }
            const VARIANTS: &'static [&'static str] = &["list", "text"];
            _serde::Deserializer::deserialize_enum(
                __deserializer,
                "SequenceType",
                VARIANTS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<SequenceType>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for SequenceType {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                SequenceType::List => _serde::Serializer::serialize_unit_variant(
                    __serializer,
                    "SequenceType",
                    0u32,
                    "list",
                ),
                SequenceType::Text => _serde::Serializer::serialize_unit_variant(
                    __serializer,
                    "SequenceType",
                    1u32,
                    "text",
                ),
            }
        }
    }
};
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for SequenceType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match (&*self,) {
            (&SequenceType::List,) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "List");
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&SequenceType::Text,) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Text");
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for SequenceType {
    #[inline]
    fn clone(&self) -> SequenceType {
        {
            *self
        }
    }
}
impl ::core::marker::StructuralPartialEq for SequenceType {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for SequenceType {
    #[inline]
    fn eq(&self, other: &SequenceType) -> bool {
        {
            let __self_vi = ::core::intrinsics::discriminant_value(&*self);
            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    _ => true,
                }
            } else {
                false
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::marker::Copy for SequenceType {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::hash::Hash for SequenceType {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        match (&*self,) {
            _ => ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self), state),
        }
    }
}
pub struct OpId(pub u64, pub ActorId);
impl ::core::marker::StructuralEq for OpId {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::Eq for OpId {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        {
            let _: ::core::cmp::AssertParamIsEq<u64>;
            let _: ::core::cmp::AssertParamIsEq<ActorId>;
        }
    }
}
impl ::core::marker::StructuralPartialEq for OpId {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for OpId {
    #[inline]
    fn eq(&self, other: &OpId) -> bool {
        match *other {
            OpId(ref __self_1_0, ref __self_1_1) => match *self {
                OpId(ref __self_0_0, ref __self_0_1) => {
                    (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1)
                }
            },
        }
    }
    #[inline]
    fn ne(&self, other: &OpId) -> bool {
        match *other {
            OpId(ref __self_1_0, ref __self_1_1) => match *self {
                OpId(ref __self_0_0, ref __self_0_1) => {
                    (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1)
                }
            },
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::hash::Hash for OpId {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        match *self {
            OpId(ref __self_0_0, ref __self_0_1) => {
                ::core::hash::Hash::hash(&(*__self_0_0), state);
                ::core::hash::Hash::hash(&(*__self_0_1), state)
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for OpId {
    #[inline]
    fn clone(&self) -> OpId {
        match *self {
            OpId(ref __self_0_0, ref __self_0_1) => OpId(
                ::core::clone::Clone::clone(&(*__self_0_0)),
                ::core::clone::Clone::clone(&(*__self_0_1)),
            ),
        }
    }
}
impl OpId {
    pub fn new(seq: u64, actor: &ActorId) -> OpId {
        OpId(seq, actor.clone())
    }
    pub fn counter(&self) -> u64 {
        self.0
    }
    pub fn increment_by(&self, by: u64) -> OpId {
        OpId(self.0 + by, self.1.clone())
    }
    /// Returns true if `other` has the same actor ID, and their counter is `delta` greater than
    /// ours.
    pub fn delta(&self, other: &Self, delta: u64) -> bool {
        self.1 == other.1 && self.0 + delta == other.0
    }
}
pub enum ObjectId {
    Id(OpId),
    Root,
}
impl ::core::marker::StructuralEq for ObjectId {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::Eq for ObjectId {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        {
            let _: ::core::cmp::AssertParamIsEq<OpId>;
        }
    }
}
impl ::core::marker::StructuralPartialEq for ObjectId {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for ObjectId {
    #[inline]
    fn eq(&self, other: &ObjectId) -> bool {
        {
            let __self_vi = ::core::intrinsics::discriminant_value(&*self);
            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (&ObjectId::Id(ref __self_0), &ObjectId::Id(ref __arg_1_0)) => {
                        (*__self_0) == (*__arg_1_0)
                    }
                    _ => true,
                }
            } else {
                false
            }
        }
    }
    #[inline]
    fn ne(&self, other: &ObjectId) -> bool {
        {
            let __self_vi = ::core::intrinsics::discriminant_value(&*self);
            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (&ObjectId::Id(ref __self_0), &ObjectId::Id(ref __arg_1_0)) => {
                        (*__self_0) != (*__arg_1_0)
                    }
                    _ => false,
                }
            } else {
                true
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for ObjectId {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match (&*self,) {
            (&ObjectId::Id(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Id");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&ObjectId::Root,) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Root");
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::hash::Hash for ObjectId {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        match (&*self,) {
            (&ObjectId::Id(ref __self_0),) => {
                ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self), state);
                ::core::hash::Hash::hash(&(*__self_0), state)
            }
            _ => ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self), state),
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for ObjectId {
    #[inline]
    fn clone(&self) -> ObjectId {
        match (&*self,) {
            (&ObjectId::Id(ref __self_0),) => {
                ObjectId::Id(::core::clone::Clone::clone(&(*__self_0)))
            }
            (&ObjectId::Root,) => ObjectId::Root,
        }
    }
}
pub enum ElementId {
    Head,
    Id(OpId),
}
impl ::core::marker::StructuralPartialEq for ElementId {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for ElementId {
    #[inline]
    fn eq(&self, other: &ElementId) -> bool {
        {
            let __self_vi = ::core::intrinsics::discriminant_value(&*self);
            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (&ElementId::Id(ref __self_0), &ElementId::Id(ref __arg_1_0)) => {
                        (*__self_0) == (*__arg_1_0)
                    }
                    _ => true,
                }
            } else {
                false
            }
        }
    }
    #[inline]
    fn ne(&self, other: &ElementId) -> bool {
        {
            let __self_vi = ::core::intrinsics::discriminant_value(&*self);
            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (&ElementId::Id(ref __self_0), &ElementId::Id(ref __arg_1_0)) => {
                        (*__self_0) != (*__arg_1_0)
                    }
                    _ => false,
                }
            } else {
                true
            }
        }
    }
}
impl ::core::marker::StructuralEq for ElementId {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::Eq for ElementId {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        {
            let _: ::core::cmp::AssertParamIsEq<OpId>;
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for ElementId {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match (&*self,) {
            (&ElementId::Head,) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Head");
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&ElementId::Id(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Id");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::hash::Hash for ElementId {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        match (&*self,) {
            (&ElementId::Id(ref __self_0),) => {
                ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self), state);
                ::core::hash::Hash::hash(&(*__self_0), state)
            }
            _ => ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self), state),
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for ElementId {
    #[inline]
    fn clone(&self) -> ElementId {
        match (&*self,) {
            (&ElementId::Head,) => ElementId::Head,
            (&ElementId::Id(ref __self_0),) => {
                ElementId::Id(::core::clone::Clone::clone(&(*__self_0)))
            }
        }
    }
}
impl ElementId {
    pub fn as_opid(&self) -> Option<&OpId> {
        match self {
            ElementId::Head => None,
            ElementId::Id(opid) => Some(opid),
        }
    }
    pub fn into_key(self) -> Key {
        Key::Seq(self)
    }
    pub fn not_head(&self) -> bool {
        match self {
            ElementId::Head => false,
            ElementId::Id(_) => true,
        }
    }
    pub fn increment_by(&self, by: u64) -> Option<Self> {
        match self {
            ElementId::Head => None,
            ElementId::Id(id) => Some(ElementId::Id(id.increment_by(by))),
        }
    }
}
#[serde(untagged)]
pub enum Key {
    Map(String),
    Seq(ElementId),
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for Key {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                Key::Map(ref __field0) => _serde::Serialize::serialize(__field0, __serializer),
                Key::Seq(ref __field0) => _serde::Serialize::serialize(__field0, __serializer),
            }
        }
    }
};
impl ::core::marker::StructuralPartialEq for Key {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for Key {
    #[inline]
    fn eq(&self, other: &Key) -> bool {
        {
            let __self_vi = ::core::intrinsics::discriminant_value(&*self);
            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (&Key::Map(ref __self_0), &Key::Map(ref __arg_1_0)) => {
                        (*__self_0) == (*__arg_1_0)
                    }
                    (&Key::Seq(ref __self_0), &Key::Seq(ref __arg_1_0)) => {
                        (*__self_0) == (*__arg_1_0)
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() },
                }
            } else {
                false
            }
        }
    }
    #[inline]
    fn ne(&self, other: &Key) -> bool {
        {
            let __self_vi = ::core::intrinsics::discriminant_value(&*self);
            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (&Key::Map(ref __self_0), &Key::Map(ref __arg_1_0)) => {
                        (*__self_0) != (*__arg_1_0)
                    }
                    (&Key::Seq(ref __self_0), &Key::Seq(ref __arg_1_0)) => {
                        (*__self_0) != (*__arg_1_0)
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() },
                }
            } else {
                true
            }
        }
    }
}
impl ::core::marker::StructuralEq for Key {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::Eq for Key {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        {
            let _: ::core::cmp::AssertParamIsEq<String>;
            let _: ::core::cmp::AssertParamIsEq<ElementId>;
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for Key {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match (&*self,) {
            (&Key::Map(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Map");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&Key::Seq(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Seq");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::hash::Hash for Key {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        match (&*self,) {
            (&Key::Map(ref __self_0),) => {
                ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self), state);
                ::core::hash::Hash::hash(&(*__self_0), state)
            }
            (&Key::Seq(ref __self_0),) => {
                ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self), state);
                ::core::hash::Hash::hash(&(*__self_0), state)
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for Key {
    #[inline]
    fn clone(&self) -> Key {
        match (&*self,) {
            (&Key::Map(ref __self_0),) => Key::Map(::core::clone::Clone::clone(&(*__self_0))),
            (&Key::Seq(ref __self_0),) => Key::Seq(::core::clone::Clone::clone(&(*__self_0))),
        }
    }
}
impl Key {
    pub fn head() -> Key {
        Key::Seq(ElementId::Head)
    }
    pub fn is_map_key(&self) -> bool {
        match self {
            Key::Map(_) => true,
            Key::Seq(_) => false,
        }
    }
    pub fn as_element_id(&self) -> Option<ElementId> {
        match self {
            Key::Map(_) => None,
            Key::Seq(eid) => Some(eid.clone()),
        }
    }
    pub fn to_opid(&self) -> Option<OpId> {
        match self.as_element_id()? {
            ElementId::Id(id) => Some(id),
            ElementId::Head => None,
        }
    }
    pub fn increment_by(&self, by: u64) -> Option<Self> {
        match self {
            Key::Map(_) => None,
            Key::Seq(eid) => eid.increment_by(by).map(Key::Seq),
        }
    }
}
pub enum DataType {
    #[serde(rename = "counter")]
    Counter,
    #[serde(rename = "timestamp")]
    Timestamp,
    #[serde(rename = "bytes")]
    Bytes,
    #[serde(rename = "cursor")]
    Cursor,
    #[serde(rename = "uint")]
    Uint,
    #[serde(rename = "int")]
    Int,
    #[serde(rename = "float64")]
    F64,
    #[serde(rename = "undefined")]
    Undefined,
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for DataType {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __field4,
                __field5,
                __field6,
                __field7,
            }
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "variant identifier")
                }
                fn visit_u64<__E>(self, __value: u64) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        4u64 => _serde::__private::Ok(__Field::__field4),
                        5u64 => _serde::__private::Ok(__Field::__field5),
                        6u64 => _serde::__private::Ok(__Field::__field6),
                        7u64 => _serde::__private::Ok(__Field::__field7),
                        _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                            _serde::de::Unexpected::Unsigned(__value),
                            &"variant index 0 <= i < 8",
                        )),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "counter" => _serde::__private::Ok(__Field::__field0),
                        "timestamp" => _serde::__private::Ok(__Field::__field1),
                        "bytes" => _serde::__private::Ok(__Field::__field2),
                        "cursor" => _serde::__private::Ok(__Field::__field3),
                        "uint" => _serde::__private::Ok(__Field::__field4),
                        "int" => _serde::__private::Ok(__Field::__field5),
                        "float64" => _serde::__private::Ok(__Field::__field6),
                        "undefined" => _serde::__private::Ok(__Field::__field7),
                        _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                            __value, VARIANTS,
                        )),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"counter" => _serde::__private::Ok(__Field::__field0),
                        b"timestamp" => _serde::__private::Ok(__Field::__field1),
                        b"bytes" => _serde::__private::Ok(__Field::__field2),
                        b"cursor" => _serde::__private::Ok(__Field::__field3),
                        b"uint" => _serde::__private::Ok(__Field::__field4),
                        b"int" => _serde::__private::Ok(__Field::__field5),
                        b"float64" => _serde::__private::Ok(__Field::__field6),
                        b"undefined" => _serde::__private::Ok(__Field::__field7),
                        _ => {
                            let __value = &_serde::__private::from_utf8_lossy(__value);
                            _serde::__private::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            ))
                        }
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<DataType>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = DataType;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "enum DataType")
                }
                fn visit_enum<__A>(
                    self,
                    __data: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::EnumAccess<'de>,
                {
                    match match _serde::de::EnumAccess::variant(__data) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        (__Field::__field0, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(DataType::Counter)
                        }
                        (__Field::__field1, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(DataType::Timestamp)
                        }
                        (__Field::__field2, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(DataType::Bytes)
                        }
                        (__Field::__field3, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(DataType::Cursor)
                        }
                        (__Field::__field4, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(DataType::Uint)
                        }
                        (__Field::__field5, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(DataType::Int)
                        }
                        (__Field::__field6, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(DataType::F64)
                        }
                        (__Field::__field7, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(DataType::Undefined)
                        }
                    }
                }
            }
            const VARIANTS: &'static [&'static str] = &[
                "counter",
                "timestamp",
                "bytes",
                "cursor",
                "uint",
                "int",
                "float64",
                "undefined",
            ];
            _serde::Deserializer::deserialize_enum(
                __deserializer,
                "DataType",
                VARIANTS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<DataType>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for DataType {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                DataType::Counter => _serde::Serializer::serialize_unit_variant(
                    __serializer,
                    "DataType",
                    0u32,
                    "counter",
                ),
                DataType::Timestamp => _serde::Serializer::serialize_unit_variant(
                    __serializer,
                    "DataType",
                    1u32,
                    "timestamp",
                ),
                DataType::Bytes => _serde::Serializer::serialize_unit_variant(
                    __serializer,
                    "DataType",
                    2u32,
                    "bytes",
                ),
                DataType::Cursor => _serde::Serializer::serialize_unit_variant(
                    __serializer,
                    "DataType",
                    3u32,
                    "cursor",
                ),
                DataType::Uint => _serde::Serializer::serialize_unit_variant(
                    __serializer,
                    "DataType",
                    4u32,
                    "uint",
                ),
                DataType::Int => _serde::Serializer::serialize_unit_variant(
                    __serializer,
                    "DataType",
                    5u32,
                    "int",
                ),
                DataType::F64 => _serde::Serializer::serialize_unit_variant(
                    __serializer,
                    "DataType",
                    6u32,
                    "float64",
                ),
                DataType::Undefined => _serde::Serializer::serialize_unit_variant(
                    __serializer,
                    "DataType",
                    7u32,
                    "undefined",
                ),
            }
        }
    }
};
impl ::core::marker::StructuralPartialEq for DataType {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for DataType {
    #[inline]
    fn eq(&self, other: &DataType) -> bool {
        {
            let __self_vi = ::core::intrinsics::discriminant_value(&*self);
            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    _ => true,
                }
            } else {
                false
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for DataType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match (&*self,) {
            (&DataType::Counter,) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Counter");
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&DataType::Timestamp,) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Timestamp");
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&DataType::Bytes,) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Bytes");
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&DataType::Cursor,) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Cursor");
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&DataType::Uint,) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Uint");
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&DataType::Int,) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Int");
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&DataType::F64,) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "F64");
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&DataType::Undefined,) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Undefined");
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for DataType {
    #[inline]
    fn clone(&self) -> DataType {
        {
            *self
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::marker::Copy for DataType {}
impl DataType {
    #[allow(clippy::trivially_copy_pass_by_ref)]
    pub fn is_undefined(d: &DataType) -> bool {
        match d {
            DataType::Undefined => true,
            _ => false,
        }
    }
}
/// We don't implement Serialize/Deserialize b/c
/// this struct will always be serialized as 2 fields
/// that are *part of* a larger struct. (It will never
/// be serialized as its own struct/map)
pub struct ScalarValues {
    pub(crate) vec: Vec<ScalarValue>,
    pub(crate) kind: ScalarValueKind,
}
impl ::core::marker::StructuralPartialEq for ScalarValues {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for ScalarValues {
    #[inline]
    fn eq(&self, other: &ScalarValues) -> bool {
        match *other {
            ScalarValues {
                vec: ref __self_1_0,
                kind: ref __self_1_1,
            } => match *self {
                ScalarValues {
                    vec: ref __self_0_0,
                    kind: ref __self_0_1,
                } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
            },
        }
    }
    #[inline]
    fn ne(&self, other: &ScalarValues) -> bool {
        match *other {
            ScalarValues {
                vec: ref __self_1_0,
                kind: ref __self_1_1,
            } => match *self {
                ScalarValues {
                    vec: ref __self_0_0,
                    kind: ref __self_0_1,
                } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
            },
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for ScalarValues {
    #[inline]
    fn clone(&self) -> ScalarValues {
        match *self {
            ScalarValues {
                vec: ref __self_0_0,
                kind: ref __self_0_1,
            } => ScalarValues {
                vec: ::core::clone::Clone::clone(&(*__self_0_0)),
                kind: ::core::clone::Clone::clone(&(*__self_0_1)),
            },
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for ScalarValues {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match *self {
            ScalarValues {
                vec: ref __self_0_0,
                kind: ref __self_0_1,
            } => {
                let debug_trait_builder =
                    &mut ::core::fmt::Formatter::debug_struct(f, "ScalarValues");
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "vec", &&(*__self_0_0));
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "kind", &&(*__self_0_1));
                ::core::fmt::DebugStruct::finish(debug_trait_builder)
            }
        }
    }
}
impl ScalarValues {
    pub fn from_values_and_datatype<'de, V: MapAccess<'de>>(
        mut old_values: Vec<ScalarValue>,
        datatype: Option<DataType>,
    ) -> Result<Self, V::Error> {
        if let Some(datatype) = datatype {
            old_values = old_values
                .iter()
                .map(|v| {
                    v.as_datatype(datatype).map_err(|e| {
                        Error::invalid_value(
                            Unexpected::Other(e.unexpected.as_str()),
                            &e.expected.as_str(),
                        )
                    })
                })
                .collect::<Result<Vec<_>, _>>()?;
        }
        let mut values: Option<ScalarValues> = None;
        for value in old_values.into_iter() {
            match values {
                Some(ref mut xs) => match xs.append(value) {
                    Some(new_kind) => {
                        let unexp = {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[""],
                                &match (&new_kind,) {
                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                        arg0,
                                        ::core::fmt::Debug::fmt,
                                    )],
                                },
                            ));
                            res
                        };
                        let exp = {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[""],
                                &match (&xs.kind,) {
                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                        arg0,
                                        ::core::fmt::Debug::fmt,
                                    )],
                                },
                            ));
                            res
                        };
                        Err(Error::invalid_value(
                            Unexpected::Other(&unexp),
                            &exp.as_str(),
                        ))?
                    }
                    None => (),
                },
                None => values = Some(value.into()),
            };
        }
        values.ok_or_else(|| Error::invalid_length(0, &"more than 0"))
    }
    pub fn from_values(old_values: Vec<ScalarValue>) -> Result<Self, InvalidScalarValues> {
        let mut values: Option<ScalarValues> = None;
        for value in old_values.into_iter() {
            match values {
                Some(ref mut xs) => match xs.append(value) {
                    Some(new_kind) => {
                        let unexp = {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[""],
                                &match (&new_kind,) {
                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                        arg0,
                                        ::core::fmt::Debug::fmt,
                                    )],
                                },
                            ));
                            res
                        };
                        let exp = {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[""],
                                &match (&xs.kind,) {
                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                        arg0,
                                        ::core::fmt::Debug::fmt,
                                    )],
                                },
                            ));
                            res
                        };
                        Err(Error::invalid_value(
                            Unexpected::Other(&unexp),
                            &exp.as_str(),
                        ))?
                    }
                    None => (),
                },
                None => values = Some(value.into()),
            };
        }
        values.ok_or_else(|| Error::invalid_length(0, &"more than 0"))
    }
    /// Try to append a `ScalarValue` to a `ScalarValues`. If we can't
    pub fn append(&mut self, v: ScalarValue) -> Option<ScalarValueKind> {
        let new_kind = ScalarValueKind::from(&v);
        if self.kind == new_kind {
            self.vec.push(v);
            None
        } else {
            Some(new_kind)
        }
    }
    pub fn get(&self, idx: usize) -> Option<&ScalarValue> {
        self.vec.get(idx)
    }
    pub fn len(&self) -> usize {
        self.vec.len()
    }
    pub fn iter(&self) -> Iter<ScalarValue> {
        self.vec.iter()
    }
    /// Returns an Option containing a `DataType` if
    /// `self` represents a numerical scalar value
    /// This is necessary b/c numerical values are not self-describing
    /// (unlike strings / bytes / etc. )
    pub fn as_numerical_datatype(&self) -> Option<DataType> {
        match self.kind {
            ScalarValueKind::Counter => Some(DataType::Counter),
            ScalarValueKind::Timestamp => Some(DataType::Timestamp),
            ScalarValueKind::Int => Some(DataType::Int),
            ScalarValueKind::Uint => Some(DataType::Uint),
            ScalarValueKind::F64 => Some(DataType::F64),
            _ => None,
        }
    }
}
impl From<ScalarValue> for ScalarValues {
    fn from(value: ScalarValue) -> Self {
        let kind = ScalarValueKind::from(&value);
        Self {
            vec: <[_]>::into_vec(box [value]),
            kind,
        }
    }
}
#[strum_discriminants(name(ScalarValueKind))]
#[serde(untagged)]
pub enum ScalarValue {
    Bytes(Vec<u8>),
    Str(String),
    Int(i64),
    Uint(u64),
    F64(f64),
    Counter(i64),
    Timestamp(i64),
    Cursor(OpId),
    Boolean(bool),
    Null,
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for ScalarValue {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                ScalarValue::Bytes(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                ScalarValue::Str(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                ScalarValue::Int(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                ScalarValue::Uint(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                ScalarValue::F64(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                ScalarValue::Counter(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                ScalarValue::Timestamp(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                ScalarValue::Cursor(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                ScalarValue::Boolean(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                ScalarValue::Null => _serde::Serializer::serialize_unit(__serializer),
            }
        }
    }
};
impl ::core::marker::StructuralPartialEq for ScalarValue {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for ScalarValue {
    #[inline]
    fn eq(&self, other: &ScalarValue) -> bool {
        {
            let __self_vi = ::core::intrinsics::discriminant_value(&*self);
            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (&ScalarValue::Bytes(ref __self_0), &ScalarValue::Bytes(ref __arg_1_0)) => {
                        (*__self_0) == (*__arg_1_0)
                    }
                    (&ScalarValue::Str(ref __self_0), &ScalarValue::Str(ref __arg_1_0)) => {
                        (*__self_0) == (*__arg_1_0)
                    }
                    (&ScalarValue::Int(ref __self_0), &ScalarValue::Int(ref __arg_1_0)) => {
                        (*__self_0) == (*__arg_1_0)
                    }
                    (&ScalarValue::Uint(ref __self_0), &ScalarValue::Uint(ref __arg_1_0)) => {
                        (*__self_0) == (*__arg_1_0)
                    }
                    (&ScalarValue::F64(ref __self_0), &ScalarValue::F64(ref __arg_1_0)) => {
                        (*__self_0) == (*__arg_1_0)
                    }
                    (&ScalarValue::Counter(ref __self_0), &ScalarValue::Counter(ref __arg_1_0)) => {
                        (*__self_0) == (*__arg_1_0)
                    }
                    (
                        &ScalarValue::Timestamp(ref __self_0),
                        &ScalarValue::Timestamp(ref __arg_1_0),
                    ) => (*__self_0) == (*__arg_1_0),
                    (&ScalarValue::Cursor(ref __self_0), &ScalarValue::Cursor(ref __arg_1_0)) => {
                        (*__self_0) == (*__arg_1_0)
                    }
                    (&ScalarValue::Boolean(ref __self_0), &ScalarValue::Boolean(ref __arg_1_0)) => {
                        (*__self_0) == (*__arg_1_0)
                    }
                    _ => true,
                }
            } else {
                false
            }
        }
    }
    #[inline]
    fn ne(&self, other: &ScalarValue) -> bool {
        {
            let __self_vi = ::core::intrinsics::discriminant_value(&*self);
            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (&ScalarValue::Bytes(ref __self_0), &ScalarValue::Bytes(ref __arg_1_0)) => {
                        (*__self_0) != (*__arg_1_0)
                    }
                    (&ScalarValue::Str(ref __self_0), &ScalarValue::Str(ref __arg_1_0)) => {
                        (*__self_0) != (*__arg_1_0)
                    }
                    (&ScalarValue::Int(ref __self_0), &ScalarValue::Int(ref __arg_1_0)) => {
                        (*__self_0) != (*__arg_1_0)
                    }
                    (&ScalarValue::Uint(ref __self_0), &ScalarValue::Uint(ref __arg_1_0)) => {
                        (*__self_0) != (*__arg_1_0)
                    }
                    (&ScalarValue::F64(ref __self_0), &ScalarValue::F64(ref __arg_1_0)) => {
                        (*__self_0) != (*__arg_1_0)
                    }
                    (&ScalarValue::Counter(ref __self_0), &ScalarValue::Counter(ref __arg_1_0)) => {
                        (*__self_0) != (*__arg_1_0)
                    }
                    (
                        &ScalarValue::Timestamp(ref __self_0),
                        &ScalarValue::Timestamp(ref __arg_1_0),
                    ) => (*__self_0) != (*__arg_1_0),
                    (&ScalarValue::Cursor(ref __self_0), &ScalarValue::Cursor(ref __arg_1_0)) => {
                        (*__self_0) != (*__arg_1_0)
                    }
                    (&ScalarValue::Boolean(ref __self_0), &ScalarValue::Boolean(ref __arg_1_0)) => {
                        (*__self_0) != (*__arg_1_0)
                    }
                    _ => false,
                }
            } else {
                true
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for ScalarValue {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match (&*self,) {
            (&ScalarValue::Bytes(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Bytes");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&ScalarValue::Str(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Str");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&ScalarValue::Int(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Int");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&ScalarValue::Uint(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Uint");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&ScalarValue::F64(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "F64");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&ScalarValue::Counter(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Counter");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&ScalarValue::Timestamp(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Timestamp");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&ScalarValue::Cursor(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Cursor");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&ScalarValue::Boolean(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Boolean");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&ScalarValue::Null,) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Null");
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for ScalarValue {
    #[inline]
    fn clone(&self) -> ScalarValue {
        match (&*self,) {
            (&ScalarValue::Bytes(ref __self_0),) => {
                ScalarValue::Bytes(::core::clone::Clone::clone(&(*__self_0)))
            }
            (&ScalarValue::Str(ref __self_0),) => {
                ScalarValue::Str(::core::clone::Clone::clone(&(*__self_0)))
            }
            (&ScalarValue::Int(ref __self_0),) => {
                ScalarValue::Int(::core::clone::Clone::clone(&(*__self_0)))
            }
            (&ScalarValue::Uint(ref __self_0),) => {
                ScalarValue::Uint(::core::clone::Clone::clone(&(*__self_0)))
            }
            (&ScalarValue::F64(ref __self_0),) => {
                ScalarValue::F64(::core::clone::Clone::clone(&(*__self_0)))
            }
            (&ScalarValue::Counter(ref __self_0),) => {
                ScalarValue::Counter(::core::clone::Clone::clone(&(*__self_0)))
            }
            (&ScalarValue::Timestamp(ref __self_0),) => {
                ScalarValue::Timestamp(::core::clone::Clone::clone(&(*__self_0)))
            }
            (&ScalarValue::Cursor(ref __self_0),) => {
                ScalarValue::Cursor(::core::clone::Clone::clone(&(*__self_0)))
            }
            (&ScalarValue::Boolean(ref __self_0),) => {
                ScalarValue::Boolean(::core::clone::Clone::clone(&(*__self_0)))
            }
            (&ScalarValue::Null,) => ScalarValue::Null,
        }
    }
}
/// Auto-generated discriminant enum variants
pub enum ScalarValueKind {
    Bytes,
    Str,
    Int,
    Uint,
    F64,
    Counter,
    Timestamp,
    Cursor,
    Boolean,
    Null,
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for ScalarValueKind {
    #[inline]
    fn clone(&self) -> ScalarValueKind {
        {
            *self
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::marker::Copy for ScalarValueKind {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for ScalarValueKind {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match (&*self,) {
            (&ScalarValueKind::Bytes,) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Bytes");
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&ScalarValueKind::Str,) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Str");
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&ScalarValueKind::Int,) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Int");
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&ScalarValueKind::Uint,) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Uint");
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&ScalarValueKind::F64,) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "F64");
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&ScalarValueKind::Counter,) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Counter");
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&ScalarValueKind::Timestamp,) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Timestamp");
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&ScalarValueKind::Cursor,) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Cursor");
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&ScalarValueKind::Boolean,) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Boolean");
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&ScalarValueKind::Null,) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Null");
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
        }
    }
}
impl ::core::marker::StructuralPartialEq for ScalarValueKind {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for ScalarValueKind {
    #[inline]
    fn eq(&self, other: &ScalarValueKind) -> bool {
        {
            let __self_vi = ::core::intrinsics::discriminant_value(&*self);
            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    _ => true,
                }
            } else {
                false
            }
        }
    }
}
impl ::core::marker::StructuralEq for ScalarValueKind {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::Eq for ScalarValueKind {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        {}
    }
}
impl ::core::convert::From<ScalarValue> for ScalarValueKind {
    fn from(val: ScalarValue) -> ScalarValueKind {
        match val {
            ScalarValue::Bytes(..) => ScalarValueKind::Bytes,
            ScalarValue::Str(..) => ScalarValueKind::Str,
            ScalarValue::Int(..) => ScalarValueKind::Int,
            ScalarValue::Uint(..) => ScalarValueKind::Uint,
            ScalarValue::F64(..) => ScalarValueKind::F64,
            ScalarValue::Counter(..) => ScalarValueKind::Counter,
            ScalarValue::Timestamp(..) => ScalarValueKind::Timestamp,
            ScalarValue::Cursor(..) => ScalarValueKind::Cursor,
            ScalarValue::Boolean(..) => ScalarValueKind::Boolean,
            ScalarValue::Null => ScalarValueKind::Null,
        }
    }
}
impl<'_enum> ::core::convert::From<&'_enum ScalarValue> for ScalarValueKind {
    fn from(val: &'_enum ScalarValue) -> ScalarValueKind {
        match val {
            ScalarValue::Bytes(..) => ScalarValueKind::Bytes,
            ScalarValue::Str(..) => ScalarValueKind::Str,
            ScalarValue::Int(..) => ScalarValueKind::Int,
            ScalarValue::Uint(..) => ScalarValueKind::Uint,
            ScalarValue::F64(..) => ScalarValueKind::F64,
            ScalarValue::Counter(..) => ScalarValueKind::Counter,
            ScalarValue::Timestamp(..) => ScalarValueKind::Timestamp,
            ScalarValue::Cursor(..) => ScalarValueKind::Cursor,
            ScalarValue::Boolean(..) => ScalarValueKind::Boolean,
            ScalarValue::Null => ScalarValueKind::Null,
        }
    }
}
impl ScalarValue {
    pub fn as_datatype(
        &self,
        datatype: DataType,
    ) -> Result<ScalarValue, error::InvalidScalarValue> {
        match (datatype, self) {
            (DataType::Counter, ScalarValue::Int(i)) => Ok(ScalarValue::Counter(*i)),
            (DataType::Counter, ScalarValue::Uint(u)) => match i64::try_from(*u) {
                Ok(i) => Ok(ScalarValue::Counter(i)),
                Err(_) => Err(error::InvalidScalarValue {
                    raw_value: self.clone(),
                    expected: "an integer".to_string(),
                    unexpected: "an integer larger than i64::max_value".to_string(),
                    datatype,
                }),
            },
            (DataType::Bytes, ScalarValue::Bytes(bytes)) => Ok(ScalarValue::Bytes(bytes.clone())),
            (DataType::Bytes, v) => Err(error::InvalidScalarValue {
                raw_value: self.clone(),
                expected: "a vector of bytes".to_string(),
                unexpected: v.to_string(),
                datatype,
            }),
            (DataType::Counter, v) => Err(error::InvalidScalarValue {
                raw_value: self.clone(),
                expected: "an integer".to_string(),
                unexpected: v.to_string(),
                datatype,
            }),
            (DataType::Timestamp, ScalarValue::Int(i)) => Ok(ScalarValue::Timestamp(*i)),
            (DataType::Timestamp, ScalarValue::Uint(u)) => match i64::try_from(*u) {
                Ok(i) => Ok(ScalarValue::Timestamp(i)),
                Err(_) => Err(error::InvalidScalarValue {
                    raw_value: self.clone(),
                    expected: "an integer".to_string(),
                    unexpected: "an integer larger than i64::max_value".to_string(),
                    datatype,
                }),
            },
            (DataType::Timestamp, v) => Err(error::InvalidScalarValue {
                raw_value: self.clone(),
                expected: "an integer".to_string(),
                unexpected: v.to_string(),
                datatype,
            }),
            (DataType::Cursor, v) => Err(error::InvalidScalarValue {
                raw_value: self.clone(),
                expected: "a cursor".to_string(),
                unexpected: v.to_string(),
                datatype,
            }),
            (DataType::Int, v) => Ok(ScalarValue::Int(v.to_i64().ok_or(
                error::InvalidScalarValue {
                    raw_value: self.clone(),
                    expected: "an int".to_string(),
                    unexpected: v.to_string(),
                    datatype,
                },
            )?)),
            (DataType::Uint, v) => Ok(ScalarValue::Uint(v.to_u64().ok_or(
                error::InvalidScalarValue {
                    raw_value: self.clone(),
                    expected: "a uint".to_string(),
                    unexpected: v.to_string(),
                    datatype,
                },
            )?)),
            (DataType::F64, v) => Ok(ScalarValue::F64(v.to_f64().ok_or(
                error::InvalidScalarValue {
                    raw_value: self.clone(),
                    expected: "an f64".to_string(),
                    unexpected: v.to_string(),
                    datatype,
                },
            )?)),
            (DataType::Undefined, _) => Ok(self.clone()),
        }
    }
    /// Returns an Option containing a `DataType` if
    /// `self` represents a numerical scalar value
    /// This is necessary b/c numerical values are not self-describing
    /// (unlike strings / bytes / etc. )
    pub fn as_numerical_datatype(&self) -> Option<DataType> {
        match self {
            ScalarValue::Counter(..) => Some(DataType::Counter),
            ScalarValue::Timestamp(..) => Some(DataType::Timestamp),
            ScalarValue::Int(..) => Some(DataType::Int),
            ScalarValue::Uint(..) => Some(DataType::Uint),
            ScalarValue::F64(..) => Some(DataType::F64),
            _ => None,
        }
    }
    pub fn datatype(&self) -> Option<DataType> {
        match self {
            ScalarValue::Counter(..) => Some(DataType::Counter),
            ScalarValue::Timestamp(..) => Some(DataType::Timestamp),
            ScalarValue::Int(..) => Some(DataType::Int),
            ScalarValue::Uint(..) => Some(DataType::Uint),
            ScalarValue::F64(..) => Some(DataType::F64),
            ScalarValue::Cursor(..) => Some(DataType::Cursor),
            _ => None,
        }
    }
    /// If this value can be coerced to an i64, return the i64 value
    pub fn to_i64(&self) -> Option<i64> {
        match self {
            ScalarValue::Int(n) => Some(*n),
            ScalarValue::Uint(n) => Some(*n as i64),
            ScalarValue::F64(n) => Some(*n as i64),
            ScalarValue::Counter(n) => Some(*n),
            ScalarValue::Timestamp(n) => Some(*n),
            _ => None,
        }
    }
    pub fn to_u64(&self) -> Option<u64> {
        match self {
            ScalarValue::Int(n) => Some(*n as u64),
            ScalarValue::Uint(n) => Some(*n),
            ScalarValue::F64(n) => Some(*n as u64),
            ScalarValue::Counter(n) => Some(*n as u64),
            ScalarValue::Timestamp(n) => Some(*n as u64),
            _ => None,
        }
    }
    pub fn to_f64(&self) -> Option<f64> {
        match self {
            ScalarValue::Int(n) => Some(*n as f64),
            ScalarValue::Uint(n) => Some(*n as f64),
            ScalarValue::F64(n) => Some(*n),
            ScalarValue::Counter(n) => Some(*n as f64),
            ScalarValue::Timestamp(n) => Some(*n as f64),
            _ => None,
        }
    }
}
pub enum OpType {
    Make(ObjType),
    /// Perform a deletion, expanding the operation to cover `n` deletions (multiOp).
    Del(NonZeroU32),
    Inc(i64),
    Set(ScalarValue),
    MultiSet(ScalarValues),
}
impl ::core::marker::StructuralPartialEq for OpType {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for OpType {
    #[inline]
    fn eq(&self, other: &OpType) -> bool {
        {
            let __self_vi = ::core::intrinsics::discriminant_value(&*self);
            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (&OpType::Make(ref __self_0), &OpType::Make(ref __arg_1_0)) => {
                        (*__self_0) == (*__arg_1_0)
                    }
                    (&OpType::Del(ref __self_0), &OpType::Del(ref __arg_1_0)) => {
                        (*__self_0) == (*__arg_1_0)
                    }
                    (&OpType::Inc(ref __self_0), &OpType::Inc(ref __arg_1_0)) => {
                        (*__self_0) == (*__arg_1_0)
                    }
                    (&OpType::Set(ref __self_0), &OpType::Set(ref __arg_1_0)) => {
                        (*__self_0) == (*__arg_1_0)
                    }
                    (&OpType::MultiSet(ref __self_0), &OpType::MultiSet(ref __arg_1_0)) => {
                        (*__self_0) == (*__arg_1_0)
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() },
                }
            } else {
                false
            }
        }
    }
    #[inline]
    fn ne(&self, other: &OpType) -> bool {
        {
            let __self_vi = ::core::intrinsics::discriminant_value(&*self);
            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (&OpType::Make(ref __self_0), &OpType::Make(ref __arg_1_0)) => {
                        (*__self_0) != (*__arg_1_0)
                    }
                    (&OpType::Del(ref __self_0), &OpType::Del(ref __arg_1_0)) => {
                        (*__self_0) != (*__arg_1_0)
                    }
                    (&OpType::Inc(ref __self_0), &OpType::Inc(ref __arg_1_0)) => {
                        (*__self_0) != (*__arg_1_0)
                    }
                    (&OpType::Set(ref __self_0), &OpType::Set(ref __arg_1_0)) => {
                        (*__self_0) != (*__arg_1_0)
                    }
                    (&OpType::MultiSet(ref __self_0), &OpType::MultiSet(ref __arg_1_0)) => {
                        (*__self_0) != (*__arg_1_0)
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() },
                }
            } else {
                true
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for OpType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match (&*self,) {
            (&OpType::Make(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Make");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&OpType::Del(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Del");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&OpType::Inc(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Inc");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&OpType::Set(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Set");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&OpType::MultiSet(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "MultiSet");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for OpType {
    #[inline]
    fn clone(&self) -> OpType {
        match (&*self,) {
            (&OpType::Make(ref __self_0),) => {
                OpType::Make(::core::clone::Clone::clone(&(*__self_0)))
            }
            (&OpType::Del(ref __self_0),) => OpType::Del(::core::clone::Clone::clone(&(*__self_0))),
            (&OpType::Inc(ref __self_0),) => OpType::Inc(::core::clone::Clone::clone(&(*__self_0))),
            (&OpType::Set(ref __self_0),) => OpType::Set(::core::clone::Clone::clone(&(*__self_0))),
            (&OpType::MultiSet(ref __self_0),) => {
                OpType::MultiSet(::core::clone::Clone::clone(&(*__self_0)))
            }
        }
    }
}
pub struct Op {
    pub action: OpType,
    pub obj: ObjectId,
    pub key: Key,
    pub pred: Vec<OpId>,
    pub insert: bool,
}
impl ::core::marker::StructuralPartialEq for Op {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for Op {
    #[inline]
    fn eq(&self, other: &Op) -> bool {
        match *other {
            Op {
                action: ref __self_1_0,
                obj: ref __self_1_1,
                key: ref __self_1_2,
                pred: ref __self_1_3,
                insert: ref __self_1_4,
            } => match *self {
                Op {
                    action: ref __self_0_0,
                    obj: ref __self_0_1,
                    key: ref __self_0_2,
                    pred: ref __self_0_3,
                    insert: ref __self_0_4,
                } => {
                    (*__self_0_0) == (*__self_1_0)
                        && (*__self_0_1) == (*__self_1_1)
                        && (*__self_0_2) == (*__self_1_2)
                        && (*__self_0_3) == (*__self_1_3)
                        && (*__self_0_4) == (*__self_1_4)
                }
            },
        }
    }
    #[inline]
    fn ne(&self, other: &Op) -> bool {
        match *other {
            Op {
                action: ref __self_1_0,
                obj: ref __self_1_1,
                key: ref __self_1_2,
                pred: ref __self_1_3,
                insert: ref __self_1_4,
            } => match *self {
                Op {
                    action: ref __self_0_0,
                    obj: ref __self_0_1,
                    key: ref __self_0_2,
                    pred: ref __self_0_3,
                    insert: ref __self_0_4,
                } => {
                    (*__self_0_0) != (*__self_1_0)
                        || (*__self_0_1) != (*__self_1_1)
                        || (*__self_0_2) != (*__self_1_2)
                        || (*__self_0_3) != (*__self_1_3)
                        || (*__self_0_4) != (*__self_1_4)
                }
            },
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for Op {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match *self {
            Op {
                action: ref __self_0_0,
                obj: ref __self_0_1,
                key: ref __self_0_2,
                pred: ref __self_0_3,
                insert: ref __self_0_4,
            } => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_struct(f, "Op");
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "action", &&(*__self_0_0));
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "obj", &&(*__self_0_1));
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "key", &&(*__self_0_2));
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "pred", &&(*__self_0_3));
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "insert", &&(*__self_0_4));
                ::core::fmt::DebugStruct::finish(debug_trait_builder)
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for Op {
    #[inline]
    fn clone(&self) -> Op {
        match *self {
            Op {
                action: ref __self_0_0,
                obj: ref __self_0_1,
                key: ref __self_0_2,
                pred: ref __self_0_3,
                insert: ref __self_0_4,
            } => Op {
                action: ::core::clone::Clone::clone(&(*__self_0_0)),
                obj: ::core::clone::Clone::clone(&(*__self_0_1)),
                key: ::core::clone::Clone::clone(&(*__self_0_2)),
                pred: ::core::clone::Clone::clone(&(*__self_0_3)),
                insert: ::core::clone::Clone::clone(&(*__self_0_4)),
            },
        }
    }
}
impl Op {
    pub fn primitive_value(&self) -> Option<ScalarValue> {
        match &self.action {
            OpType::Set(v) => Some(v.clone()),
            OpType::Inc(i) => Some(ScalarValue::Int(*i)),
            _ => None,
        }
    }
    pub fn obj_type(&self) -> Option<ObjType> {
        match self.action {
            OpType::Make(o) => Some(o),
            _ => None,
        }
    }
    pub fn to_i64(&self) -> Option<i64> {
        self.primitive_value().as_ref().and_then(|v| v.to_i64())
    }
}
pub struct ChangeHash(pub [u8; 32]);
impl ::core::marker::StructuralEq for ChangeHash {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::Eq for ChangeHash {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        {
            let _: ::core::cmp::AssertParamIsEq<[u8; 32]>;
        }
    }
}
impl ::core::marker::StructuralPartialEq for ChangeHash {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for ChangeHash {
    #[inline]
    fn eq(&self, other: &ChangeHash) -> bool {
        match *other {
            ChangeHash(ref __self_1_0) => match *self {
                ChangeHash(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
            },
        }
    }
    #[inline]
    fn ne(&self, other: &ChangeHash) -> bool {
        match *other {
            ChangeHash(ref __self_1_0) => match *self {
                ChangeHash(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
            },
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::hash::Hash for ChangeHash {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        match *self {
            ChangeHash(ref __self_0_0) => ::core::hash::Hash::hash(&(*__self_0_0), state),
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for ChangeHash {
    #[inline]
    fn clone(&self) -> ChangeHash {
        {
            let _: ::core::clone::AssertParamIsClone<[u8; 32]>;
            *self
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialOrd for ChangeHash {
    #[inline]
    fn partial_cmp(&self, other: &ChangeHash) -> ::core::option::Option<::core::cmp::Ordering> {
        match *other {
            ChangeHash(ref __self_1_0) => match *self {
                ChangeHash(ref __self_0_0) => {
                    match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                        }
                        cmp => cmp,
                    }
                }
            },
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::Ord for ChangeHash {
    #[inline]
    fn cmp(&self, other: &ChangeHash) -> ::core::cmp::Ordering {
        match *other {
            ChangeHash(ref __self_1_0) => match *self {
                ChangeHash(ref __self_0_0) => {
                    match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                        ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                        cmp => cmp,
                    }
                }
            },
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::marker::Copy for ChangeHash {}
impl fmt::Debug for ChangeHash {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_tuple("ChangeHash")
            .field(&hex::encode(&self.0))
            .finish()
    }
}
pub enum Diff {
    Map(MapDiff),
    Seq(SeqDiff),
    Value(ScalarValue),
    Cursor(CursorDiff),
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for Diff {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match (&*self,) {
            (&Diff::Map(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Map");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&Diff::Seq(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Seq");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&Diff::Value(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Value");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&Diff::Cursor(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Cursor");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
        }
    }
}
impl ::core::marker::StructuralPartialEq for Diff {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for Diff {
    #[inline]
    fn eq(&self, other: &Diff) -> bool {
        {
            let __self_vi = ::core::intrinsics::discriminant_value(&*self);
            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (&Diff::Map(ref __self_0), &Diff::Map(ref __arg_1_0)) => {
                        (*__self_0) == (*__arg_1_0)
                    }
                    (&Diff::Seq(ref __self_0), &Diff::Seq(ref __arg_1_0)) => {
                        (*__self_0) == (*__arg_1_0)
                    }
                    (&Diff::Value(ref __self_0), &Diff::Value(ref __arg_1_0)) => {
                        (*__self_0) == (*__arg_1_0)
                    }
                    (&Diff::Cursor(ref __self_0), &Diff::Cursor(ref __arg_1_0)) => {
                        (*__self_0) == (*__arg_1_0)
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() },
                }
            } else {
                false
            }
        }
    }
    #[inline]
    fn ne(&self, other: &Diff) -> bool {
        {
            let __self_vi = ::core::intrinsics::discriminant_value(&*self);
            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (&Diff::Map(ref __self_0), &Diff::Map(ref __arg_1_0)) => {
                        (*__self_0) != (*__arg_1_0)
                    }
                    (&Diff::Seq(ref __self_0), &Diff::Seq(ref __arg_1_0)) => {
                        (*__self_0) != (*__arg_1_0)
                    }
                    (&Diff::Value(ref __self_0), &Diff::Value(ref __arg_1_0)) => {
                        (*__self_0) != (*__arg_1_0)
                    }
                    (&Diff::Cursor(ref __self_0), &Diff::Cursor(ref __arg_1_0)) => {
                        (*__self_0) != (*__arg_1_0)
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() },
                }
            } else {
                true
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for Diff {
    #[inline]
    fn clone(&self) -> Diff {
        match (&*self,) {
            (&Diff::Map(ref __self_0),) => Diff::Map(::core::clone::Clone::clone(&(*__self_0))),
            (&Diff::Seq(ref __self_0),) => Diff::Seq(::core::clone::Clone::clone(&(*__self_0))),
            (&Diff::Value(ref __self_0),) => Diff::Value(::core::clone::Clone::clone(&(*__self_0))),
            (&Diff::Cursor(ref __self_0),) => {
                Diff::Cursor(::core::clone::Clone::clone(&(*__self_0)))
            }
        }
    }
}
#[serde(rename_all = "camelCase")]
pub struct MapDiff {
    pub object_id: ObjectId,
    #[serde(rename = "type")]
    pub obj_type: MapType,
    pub props: HashMap<String, HashMap<OpId, Diff>>,
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for MapDiff {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __ignore,
            }
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "field identifier")
                }
                fn visit_u64<__E>(self, __value: u64) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "objectId" => _serde::__private::Ok(__Field::__field0),
                        "type" => _serde::__private::Ok(__Field::__field1),
                        "props" => _serde::__private::Ok(__Field::__field2),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"objectId" => _serde::__private::Ok(__Field::__field0),
                        b"type" => _serde::__private::Ok(__Field::__field1),
                        b"props" => _serde::__private::Ok(__Field::__field2),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<MapDiff>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = MapDiff;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "struct MapDiff")
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 =
                        match match _serde::de::SeqAccess::next_element::<ObjectId>(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct MapDiff with 3 elements",
                                ));
                            }
                        };
                    let __field1 =
                        match match _serde::de::SeqAccess::next_element::<MapType>(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct MapDiff with 3 elements",
                                ));
                            }
                        };
                    let __field2 = match match _serde::de::SeqAccess::next_element::<
                        HashMap<String, HashMap<OpId, Diff>>,
                    >(&mut __seq)
                    {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(_serde::de::Error::invalid_length(
                                2usize,
                                &"struct MapDiff with 3 elements",
                            ));
                        }
                    };
                    _serde::__private::Ok(MapDiff {
                        object_id: __field0,
                        obj_type: __field1,
                        props: __field2,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<ObjectId> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<MapType> = _serde::__private::None;
                    let mut __field2: _serde::__private::Option<
                        HashMap<String, HashMap<OpId, Diff>>,
                    > = _serde::__private::None;
                    while let _serde::__private::Some(__key) =
                        match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        }
                    {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "objectId",
                                        ),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<ObjectId>(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("type"),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<MapType>(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private::Option::is_some(&__field2) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("props"),
                                    );
                                }
                                __field2 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<
                                        HashMap<String, HashMap<OpId, Diff>>,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            _ => {
                                let _ = match _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)
                                {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("objectId") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("type") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private::Some(__field2) => __field2,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("props") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    _serde::__private::Ok(MapDiff {
                        object_id: __field0,
                        obj_type: __field1,
                        props: __field2,
                    })
                }
            }
            const FIELDS: &'static [&'static str] = &["objectId", "type", "props"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "MapDiff",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<MapDiff>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for MapDiff {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = match _serde::Serializer::serialize_struct(
                __serializer,
                "MapDiff",
                false as usize + 1 + 1 + 1,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "objectId",
                &self.object_id,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "type",
                &self.obj_type,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "props",
                &self.props,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for MapDiff {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match *self {
            MapDiff {
                object_id: ref __self_0_0,
                obj_type: ref __self_0_1,
                props: ref __self_0_2,
            } => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_struct(f, "MapDiff");
                let _ = ::core::fmt::DebugStruct::field(
                    debug_trait_builder,
                    "object_id",
                    &&(*__self_0_0),
                );
                let _ = ::core::fmt::DebugStruct::field(
                    debug_trait_builder,
                    "obj_type",
                    &&(*__self_0_1),
                );
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "props", &&(*__self_0_2));
                ::core::fmt::DebugStruct::finish(debug_trait_builder)
            }
        }
    }
}
impl ::core::marker::StructuralPartialEq for MapDiff {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for MapDiff {
    #[inline]
    fn eq(&self, other: &MapDiff) -> bool {
        match *other {
            MapDiff {
                object_id: ref __self_1_0,
                obj_type: ref __self_1_1,
                props: ref __self_1_2,
            } => match *self {
                MapDiff {
                    object_id: ref __self_0_0,
                    obj_type: ref __self_0_1,
                    props: ref __self_0_2,
                } => {
                    (*__self_0_0) == (*__self_1_0)
                        && (*__self_0_1) == (*__self_1_1)
                        && (*__self_0_2) == (*__self_1_2)
                }
            },
        }
    }
    #[inline]
    fn ne(&self, other: &MapDiff) -> bool {
        match *other {
            MapDiff {
                object_id: ref __self_1_0,
                obj_type: ref __self_1_1,
                props: ref __self_1_2,
            } => match *self {
                MapDiff {
                    object_id: ref __self_0_0,
                    obj_type: ref __self_0_1,
                    props: ref __self_0_2,
                } => {
                    (*__self_0_0) != (*__self_1_0)
                        || (*__self_0_1) != (*__self_1_1)
                        || (*__self_0_2) != (*__self_1_2)
                }
            },
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for MapDiff {
    #[inline]
    fn clone(&self) -> MapDiff {
        match *self {
            MapDiff {
                object_id: ref __self_0_0,
                obj_type: ref __self_0_1,
                props: ref __self_0_2,
            } => MapDiff {
                object_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                obj_type: ::core::clone::Clone::clone(&(*__self_0_1)),
                props: ::core::clone::Clone::clone(&(*__self_0_2)),
            },
        }
    }
}
#[serde(rename_all = "camelCase")]
pub struct SeqDiff {
    pub object_id: ObjectId,
    #[serde(rename = "type")]
    pub obj_type: SequenceType,
    pub edits: Vec<DiffEdit>,
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for SeqDiff {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __ignore,
            }
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "field identifier")
                }
                fn visit_u64<__E>(self, __value: u64) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "objectId" => _serde::__private::Ok(__Field::__field0),
                        "type" => _serde::__private::Ok(__Field::__field1),
                        "edits" => _serde::__private::Ok(__Field::__field2),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"objectId" => _serde::__private::Ok(__Field::__field0),
                        b"type" => _serde::__private::Ok(__Field::__field1),
                        b"edits" => _serde::__private::Ok(__Field::__field2),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<SeqDiff>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = SeqDiff;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "struct SeqDiff")
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 =
                        match match _serde::de::SeqAccess::next_element::<ObjectId>(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct SeqDiff with 3 elements",
                                ));
                            }
                        };
                    let __field1 =
                        match match _serde::de::SeqAccess::next_element::<SequenceType>(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct SeqDiff with 3 elements",
                                ));
                            }
                        };
                    let __field2 = match match _serde::de::SeqAccess::next_element::<Vec<DiffEdit>>(
                        &mut __seq,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(_serde::de::Error::invalid_length(
                                2usize,
                                &"struct SeqDiff with 3 elements",
                            ));
                        }
                    };
                    _serde::__private::Ok(SeqDiff {
                        object_id: __field0,
                        obj_type: __field1,
                        edits: __field2,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<ObjectId> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<SequenceType> =
                        _serde::__private::None;
                    let mut __field2: _serde::__private::Option<Vec<DiffEdit>> =
                        _serde::__private::None;
                    while let _serde::__private::Some(__key) =
                        match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        }
                    {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "objectId",
                                        ),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<ObjectId>(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("type"),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<SequenceType>(
                                        &mut __map,
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private::Option::is_some(&__field2) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("edits"),
                                    );
                                }
                                __field2 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<Vec<DiffEdit>>(
                                        &mut __map,
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            _ => {
                                let _ = match _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)
                                {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("objectId") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("type") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private::Some(__field2) => __field2,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("edits") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    _serde::__private::Ok(SeqDiff {
                        object_id: __field0,
                        obj_type: __field1,
                        edits: __field2,
                    })
                }
            }
            const FIELDS: &'static [&'static str] = &["objectId", "type", "edits"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "SeqDiff",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<SeqDiff>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for SeqDiff {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = match _serde::Serializer::serialize_struct(
                __serializer,
                "SeqDiff",
                false as usize + 1 + 1 + 1,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "objectId",
                &self.object_id,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "type",
                &self.obj_type,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "edits",
                &self.edits,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for SeqDiff {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match *self {
            SeqDiff {
                object_id: ref __self_0_0,
                obj_type: ref __self_0_1,
                edits: ref __self_0_2,
            } => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_struct(f, "SeqDiff");
                let _ = ::core::fmt::DebugStruct::field(
                    debug_trait_builder,
                    "object_id",
                    &&(*__self_0_0),
                );
                let _ = ::core::fmt::DebugStruct::field(
                    debug_trait_builder,
                    "obj_type",
                    &&(*__self_0_1),
                );
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "edits", &&(*__self_0_2));
                ::core::fmt::DebugStruct::finish(debug_trait_builder)
            }
        }
    }
}
impl ::core::marker::StructuralPartialEq for SeqDiff {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for SeqDiff {
    #[inline]
    fn eq(&self, other: &SeqDiff) -> bool {
        match *other {
            SeqDiff {
                object_id: ref __self_1_0,
                obj_type: ref __self_1_1,
                edits: ref __self_1_2,
            } => match *self {
                SeqDiff {
                    object_id: ref __self_0_0,
                    obj_type: ref __self_0_1,
                    edits: ref __self_0_2,
                } => {
                    (*__self_0_0) == (*__self_1_0)
                        && (*__self_0_1) == (*__self_1_1)
                        && (*__self_0_2) == (*__self_1_2)
                }
            },
        }
    }
    #[inline]
    fn ne(&self, other: &SeqDiff) -> bool {
        match *other {
            SeqDiff {
                object_id: ref __self_1_0,
                obj_type: ref __self_1_1,
                edits: ref __self_1_2,
            } => match *self {
                SeqDiff {
                    object_id: ref __self_0_0,
                    obj_type: ref __self_0_1,
                    edits: ref __self_0_2,
                } => {
                    (*__self_0_0) != (*__self_1_0)
                        || (*__self_0_1) != (*__self_1_1)
                        || (*__self_0_2) != (*__self_1_2)
                }
            },
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for SeqDiff {
    #[inline]
    fn clone(&self) -> SeqDiff {
        match *self {
            SeqDiff {
                object_id: ref __self_0_0,
                obj_type: ref __self_0_1,
                edits: ref __self_0_2,
            } => SeqDiff {
                object_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                obj_type: ::core::clone::Clone::clone(&(*__self_0_1)),
                edits: ::core::clone::Clone::clone(&(*__self_0_2)),
            },
        }
    }
}
#[serde(rename_all = "camelCase")]
pub struct ObjDiff {
    pub object_id: ObjectId,
    #[serde(rename = "type")]
    pub obj_type: ObjType,
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for ObjDiff {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            enum __Field {
                __field0,
                __field1,
                __ignore,
            }
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "field identifier")
                }
                fn visit_u64<__E>(self, __value: u64) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "objectId" => _serde::__private::Ok(__Field::__field0),
                        "type" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"objectId" => _serde::__private::Ok(__Field::__field0),
                        b"type" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<ObjDiff>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = ObjDiff;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "struct ObjDiff")
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 =
                        match match _serde::de::SeqAccess::next_element::<ObjectId>(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct ObjDiff with 2 elements",
                                ));
                            }
                        };
                    let __field1 =
                        match match _serde::de::SeqAccess::next_element::<ObjType>(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct ObjDiff with 2 elements",
                                ));
                            }
                        };
                    _serde::__private::Ok(ObjDiff {
                        object_id: __field0,
                        obj_type: __field1,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<ObjectId> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<ObjType> = _serde::__private::None;
                    while let _serde::__private::Some(__key) =
                        match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        }
                    {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "objectId",
                                        ),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<ObjectId>(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("type"),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<ObjType>(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            _ => {
                                let _ = match _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)
                                {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("objectId") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("type") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    _serde::__private::Ok(ObjDiff {
                        object_id: __field0,
                        obj_type: __field1,
                    })
                }
            }
            const FIELDS: &'static [&'static str] = &["objectId", "type"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "ObjDiff",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<ObjDiff>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for ObjDiff {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = match _serde::Serializer::serialize_struct(
                __serializer,
                "ObjDiff",
                false as usize + 1 + 1,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "objectId",
                &self.object_id,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "type",
                &self.obj_type,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for ObjDiff {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match *self {
            ObjDiff {
                object_id: ref __self_0_0,
                obj_type: ref __self_0_1,
            } => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_struct(f, "ObjDiff");
                let _ = ::core::fmt::DebugStruct::field(
                    debug_trait_builder,
                    "object_id",
                    &&(*__self_0_0),
                );
                let _ = ::core::fmt::DebugStruct::field(
                    debug_trait_builder,
                    "obj_type",
                    &&(*__self_0_1),
                );
                ::core::fmt::DebugStruct::finish(debug_trait_builder)
            }
        }
    }
}
impl ::core::marker::StructuralPartialEq for ObjDiff {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for ObjDiff {
    #[inline]
    fn eq(&self, other: &ObjDiff) -> bool {
        match *other {
            ObjDiff {
                object_id: ref __self_1_0,
                obj_type: ref __self_1_1,
            } => match *self {
                ObjDiff {
                    object_id: ref __self_0_0,
                    obj_type: ref __self_0_1,
                } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
            },
        }
    }
    #[inline]
    fn ne(&self, other: &ObjDiff) -> bool {
        match *other {
            ObjDiff {
                object_id: ref __self_1_0,
                obj_type: ref __self_1_1,
            } => match *self {
                ObjDiff {
                    object_id: ref __self_0_0,
                    obj_type: ref __self_0_1,
                } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
            },
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for ObjDiff {
    #[inline]
    fn clone(&self) -> ObjDiff {
        match *self {
            ObjDiff {
                object_id: ref __self_0_0,
                obj_type: ref __self_0_1,
            } => ObjDiff {
                object_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                obj_type: ::core::clone::Clone::clone(&(*__self_0_1)),
            },
        }
    }
}
pub struct CursorDiff {
    pub object_id: ObjectId,
    pub elem_id: OpId,
    pub index: u32,
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for CursorDiff {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match *self {
            CursorDiff {
                object_id: ref __self_0_0,
                elem_id: ref __self_0_1,
                index: ref __self_0_2,
            } => {
                let debug_trait_builder =
                    &mut ::core::fmt::Formatter::debug_struct(f, "CursorDiff");
                let _ = ::core::fmt::DebugStruct::field(
                    debug_trait_builder,
                    "object_id",
                    &&(*__self_0_0),
                );
                let _ = ::core::fmt::DebugStruct::field(
                    debug_trait_builder,
                    "elem_id",
                    &&(*__self_0_1),
                );
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "index", &&(*__self_0_2));
                ::core::fmt::DebugStruct::finish(debug_trait_builder)
            }
        }
    }
}
impl ::core::marker::StructuralPartialEq for CursorDiff {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for CursorDiff {
    #[inline]
    fn eq(&self, other: &CursorDiff) -> bool {
        match *other {
            CursorDiff {
                object_id: ref __self_1_0,
                elem_id: ref __self_1_1,
                index: ref __self_1_2,
            } => match *self {
                CursorDiff {
                    object_id: ref __self_0_0,
                    elem_id: ref __self_0_1,
                    index: ref __self_0_2,
                } => {
                    (*__self_0_0) == (*__self_1_0)
                        && (*__self_0_1) == (*__self_1_1)
                        && (*__self_0_2) == (*__self_1_2)
                }
            },
        }
    }
    #[inline]
    fn ne(&self, other: &CursorDiff) -> bool {
        match *other {
            CursorDiff {
                object_id: ref __self_1_0,
                elem_id: ref __self_1_1,
                index: ref __self_1_2,
            } => match *self {
                CursorDiff {
                    object_id: ref __self_0_0,
                    elem_id: ref __self_0_1,
                    index: ref __self_0_2,
                } => {
                    (*__self_0_0) != (*__self_1_0)
                        || (*__self_0_1) != (*__self_1_1)
                        || (*__self_0_2) != (*__self_1_2)
                }
            },
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for CursorDiff {
    #[inline]
    fn clone(&self) -> CursorDiff {
        match *self {
            CursorDiff {
                object_id: ref __self_0_0,
                elem_id: ref __self_0_1,
                index: ref __self_0_2,
            } => CursorDiff {
                object_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                elem_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                index: ::core::clone::Clone::clone(&(*__self_0_2)),
            },
        }
    }
}
#[serde(rename_all = "camelCase", tag = "action")]
pub enum DiffEdit {
    /// Describes the insertion of a single element into a list or text object.
    /// The element can be a nested object.
    #[serde(rename = "insert", rename_all = "camelCase")]
    SingleElementInsert {
        /// the list index at which to insert the new element
        index: u64,
        /// the unique element ID of the new list element
        elem_id: ElementId,
        /// ID of the operation that assigned this value
        op_id: OpId,
        value: Diff,
    },
    /// Describes the insertion of a consecutive sequence of primitive values into
    /// a list or text object. In the case of text, the values are strings (each
    /// character as a separate string value). Each inserted value is given a
    /// consecutive element ID: starting with `elemId` for the first value, the
    /// subsequent values are given elemIds with the same actor ID and incrementing
    /// counters. To insert non-primitive values, use SingleInsertEdit.
    /// We need to use a separate struct here to implement custom
    /// serialization and deserialization logic (due to the presence
    /// of the datatype field)
    #[serde(rename = "multi-insert")]
    MultiElementInsert(MultiElementInsert),
    /// Describes the update of the value or nested object at a particular index
    /// of a list or text object. In the case where there are multiple conflicted
    /// values at the same list index, multiple UpdateEdits with the same index
    /// (but different opIds) appear in the edits array of ListDiff.
    #[serde(rename_all = "camelCase")]
    Update {
        /// the list index to update
        index: u64,
        /// ID of the operation that assigned this value
        op_id: OpId,
        value: Diff,
    },
    #[serde(rename_all = "camelCase")]
    Remove { index: u64, count: u64 },
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for DiffEdit {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                DiffEdit::SingleElementInsert {
                    ref index,
                    ref elem_id,
                    ref op_id,
                    ref value,
                } => {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "DiffEdit",
                        0 + 1 + 1 + 1 + 1 + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "action",
                        "insert",
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "index",
                        index,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "elemId",
                        elem_id,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "opId",
                        op_id,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "value",
                        value,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
                DiffEdit::MultiElementInsert(ref __field0) => {
                    _serde::__private::ser::serialize_tagged_newtype(
                        __serializer,
                        "DiffEdit",
                        "MultiElementInsert",
                        "action",
                        "multi-insert",
                        __field0,
                    )
                }
                DiffEdit::Update {
                    ref index,
                    ref op_id,
                    ref value,
                } => {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "DiffEdit",
                        0 + 1 + 1 + 1 + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "action",
                        "update",
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "index",
                        index,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "opId",
                        op_id,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "value",
                        value,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
                DiffEdit::Remove {
                    ref index,
                    ref count,
                } => {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "DiffEdit",
                        0 + 1 + 1 + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "action",
                        "remove",
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "index",
                        index,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "count",
                        count,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for DiffEdit {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
            }
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "variant identifier")
                }
                fn visit_u64<__E>(self, __value: u64) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                            _serde::de::Unexpected::Unsigned(__value),
                            &"variant index 0 <= i < 4",
                        )),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "insert" => _serde::__private::Ok(__Field::__field0),
                        "multi-insert" => _serde::__private::Ok(__Field::__field1),
                        "update" => _serde::__private::Ok(__Field::__field2),
                        "remove" => _serde::__private::Ok(__Field::__field3),
                        _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                            __value, VARIANTS,
                        )),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"insert" => _serde::__private::Ok(__Field::__field0),
                        b"multi-insert" => _serde::__private::Ok(__Field::__field1),
                        b"update" => _serde::__private::Ok(__Field::__field2),
                        b"remove" => _serde::__private::Ok(__Field::__field3),
                        _ => {
                            let __value = &_serde::__private::from_utf8_lossy(__value);
                            _serde::__private::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            ))
                        }
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            const VARIANTS: &'static [&'static str] =
                &["insert", "multi-insert", "update", "remove"];
            let __tagged = match _serde::Deserializer::deserialize_any(
                __deserializer,
                _serde::__private::de::TaggedContentVisitor::<__Field>::new(
                    "action",
                    "internally tagged enum DiffEdit",
                ),
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match __tagged.tag {
                __Field::__field0 => {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "index" => _serde::__private::Ok(__Field::__field0),
                                "elemId" => _serde::__private::Ok(__Field::__field1),
                                "opId" => _serde::__private::Ok(__Field::__field2),
                                "value" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"index" => _serde::__private::Ok(__Field::__field0),
                                b"elemId" => _serde::__private::Ok(__Field::__field1),
                                b"opId" => _serde::__private::Ok(__Field::__field2),
                                b"value" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DiffEdit>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DiffEdit;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct variant DiffEdit::SingleElementInsert",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<u64>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant DiffEdit::SingleElementInsert with 4 elements")) ;
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                ElementId,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct variant DiffEdit::SingleElementInsert with 4 elements")) ;
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<OpId>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct variant DiffEdit::SingleElementInsert with 4 elements")) ;
                                }
                            };
                            let __field3 = match match _serde::de::SeqAccess::next_element::<Diff>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct variant DiffEdit::SingleElementInsert with 4 elements")) ;
                                }
                            };
                            _serde::__private::Ok(DiffEdit::SingleElementInsert {
                                index: __field0,
                                elem_id: __field1,
                                op_id: __field2,
                                value: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u64> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<ElementId> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<OpId> =
                                _serde::__private::None;
                            let mut __field3: _serde::__private::Option<Diff> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "index",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<u64>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "elemId",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<ElementId>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "opId",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<OpId>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "value",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Diff>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("index") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("elemId") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("opId") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("value") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(DiffEdit::SingleElementInsert {
                                index: __field0,
                                elem_id: __field1,
                                op_id: __field2,
                                value: __field3,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["index", "elemId", "opId", "value"];
                    _serde::Deserializer::deserialize_any(
                        _serde::__private::de::ContentDeserializer::<__D::Error>::new(
                            __tagged.content,
                        ),
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DiffEdit>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
                __Field::__field1 => _serde::__private::Result::map(
                    <MultiElementInsert as _serde::Deserialize>::deserialize(
                        _serde::__private::de::ContentDeserializer::<__D::Error>::new(
                            __tagged.content,
                        ),
                    ),
                    DiffEdit::MultiElementInsert,
                ),
                __Field::__field2 => {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "index" => _serde::__private::Ok(__Field::__field0),
                                "opId" => _serde::__private::Ok(__Field::__field1),
                                "value" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"index" => _serde::__private::Ok(__Field::__field0),
                                b"opId" => _serde::__private::Ok(__Field::__field1),
                                b"value" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DiffEdit>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DiffEdit;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct variant DiffEdit::Update",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<u64>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct variant DiffEdit::Update with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 =
                                match match _serde::de::SeqAccess::next_element::<OpId>(&mut __seq)
                                {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct variant DiffEdit::Update with 3 elements",
                                            ),
                                        );
                                    }
                                };
                            let __field2 =
                                match match _serde::de::SeqAccess::next_element::<Diff>(&mut __seq)
                                {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct variant DiffEdit::Update with 3 elements",
                                            ),
                                        );
                                    }
                                };
                            _serde::__private::Ok(DiffEdit::Update {
                                index: __field0,
                                op_id: __field1,
                                value: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u64> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<OpId> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<Diff> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "index",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<u64>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "opId",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<OpId>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "value",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Diff>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("index") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("opId") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("value") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(DiffEdit::Update {
                                index: __field0,
                                op_id: __field1,
                                value: __field2,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["index", "opId", "value"];
                    _serde::Deserializer::deserialize_any(
                        _serde::__private::de::ContentDeserializer::<__D::Error>::new(
                            __tagged.content,
                        ),
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DiffEdit>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
                __Field::__field3 => {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "index" => _serde::__private::Ok(__Field::__field0),
                                "count" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"index" => _serde::__private::Ok(__Field::__field0),
                                b"count" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DiffEdit>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DiffEdit;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct variant DiffEdit::Remove",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<u64>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct variant DiffEdit::Remove with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<u64>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct variant DiffEdit::Remove with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DiffEdit::Remove {
                                index: __field0,
                                count: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u64> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<u64> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "index",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<u64>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "count",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<u64>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("index") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("count") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(DiffEdit::Remove {
                                index: __field0,
                                count: __field1,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["index", "count"];
                    _serde::Deserializer::deserialize_any(
                        _serde::__private::de::ContentDeserializer::<__D::Error>::new(
                            __tagged.content,
                        ),
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DiffEdit>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        }
    }
};
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for DiffEdit {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match (&*self,) {
            (&DiffEdit::SingleElementInsert {
                index: ref __self_0,
                elem_id: ref __self_1,
                op_id: ref __self_2,
                value: ref __self_3,
            },) => {
                let debug_trait_builder =
                    &mut ::core::fmt::Formatter::debug_struct(f, "SingleElementInsert");
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "index", &&(*__self_0));
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "elem_id", &&(*__self_1));
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "op_id", &&(*__self_2));
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "value", &&(*__self_3));
                ::core::fmt::DebugStruct::finish(debug_trait_builder)
            }
            (&DiffEdit::MultiElementInsert(ref __self_0),) => {
                let debug_trait_builder =
                    &mut ::core::fmt::Formatter::debug_tuple(f, "MultiElementInsert");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&DiffEdit::Update {
                index: ref __self_0,
                op_id: ref __self_1,
                value: ref __self_2,
            },) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_struct(f, "Update");
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "index", &&(*__self_0));
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "op_id", &&(*__self_1));
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "value", &&(*__self_2));
                ::core::fmt::DebugStruct::finish(debug_trait_builder)
            }
            (&DiffEdit::Remove {
                index: ref __self_0,
                count: ref __self_1,
            },) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_struct(f, "Remove");
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "index", &&(*__self_0));
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "count", &&(*__self_1));
                ::core::fmt::DebugStruct::finish(debug_trait_builder)
            }
        }
    }
}
impl ::core::marker::StructuralPartialEq for DiffEdit {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for DiffEdit {
    #[inline]
    fn eq(&self, other: &DiffEdit) -> bool {
        {
            let __self_vi = ::core::intrinsics::discriminant_value(&*self);
            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (
                        &DiffEdit::SingleElementInsert {
                            index: ref __self_0,
                            elem_id: ref __self_1,
                            op_id: ref __self_2,
                            value: ref __self_3,
                        },
                        &DiffEdit::SingleElementInsert {
                            index: ref __arg_1_0,
                            elem_id: ref __arg_1_1,
                            op_id: ref __arg_1_2,
                            value: ref __arg_1_3,
                        },
                    ) => {
                        (*__self_0) == (*__arg_1_0)
                            && (*__self_1) == (*__arg_1_1)
                            && (*__self_2) == (*__arg_1_2)
                            && (*__self_3) == (*__arg_1_3)
                    }
                    (
                        &DiffEdit::MultiElementInsert(ref __self_0),
                        &DiffEdit::MultiElementInsert(ref __arg_1_0),
                    ) => (*__self_0) == (*__arg_1_0),
                    (
                        &DiffEdit::Update {
                            index: ref __self_0,
                            op_id: ref __self_1,
                            value: ref __self_2,
                        },
                        &DiffEdit::Update {
                            index: ref __arg_1_0,
                            op_id: ref __arg_1_1,
                            value: ref __arg_1_2,
                        },
                    ) => {
                        (*__self_0) == (*__arg_1_0)
                            && (*__self_1) == (*__arg_1_1)
                            && (*__self_2) == (*__arg_1_2)
                    }
                    (
                        &DiffEdit::Remove {
                            index: ref __self_0,
                            count: ref __self_1,
                        },
                        &DiffEdit::Remove {
                            index: ref __arg_1_0,
                            count: ref __arg_1_1,
                        },
                    ) => (*__self_0) == (*__arg_1_0) && (*__self_1) == (*__arg_1_1),
                    _ => unsafe { ::core::intrinsics::unreachable() },
                }
            } else {
                false
            }
        }
    }
    #[inline]
    fn ne(&self, other: &DiffEdit) -> bool {
        {
            let __self_vi = ::core::intrinsics::discriminant_value(&*self);
            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (
                        &DiffEdit::SingleElementInsert {
                            index: ref __self_0,
                            elem_id: ref __self_1,
                            op_id: ref __self_2,
                            value: ref __self_3,
                        },
                        &DiffEdit::SingleElementInsert {
                            index: ref __arg_1_0,
                            elem_id: ref __arg_1_1,
                            op_id: ref __arg_1_2,
                            value: ref __arg_1_3,
                        },
                    ) => {
                        (*__self_0) != (*__arg_1_0)
                            || (*__self_1) != (*__arg_1_1)
                            || (*__self_2) != (*__arg_1_2)
                            || (*__self_3) != (*__arg_1_3)
                    }
                    (
                        &DiffEdit::MultiElementInsert(ref __self_0),
                        &DiffEdit::MultiElementInsert(ref __arg_1_0),
                    ) => (*__self_0) != (*__arg_1_0),
                    (
                        &DiffEdit::Update {
                            index: ref __self_0,
                            op_id: ref __self_1,
                            value: ref __self_2,
                        },
                        &DiffEdit::Update {
                            index: ref __arg_1_0,
                            op_id: ref __arg_1_1,
                            value: ref __arg_1_2,
                        },
                    ) => {
                        (*__self_0) != (*__arg_1_0)
                            || (*__self_1) != (*__arg_1_1)
                            || (*__self_2) != (*__arg_1_2)
                    }
                    (
                        &DiffEdit::Remove {
                            index: ref __self_0,
                            count: ref __self_1,
                        },
                        &DiffEdit::Remove {
                            index: ref __arg_1_0,
                            count: ref __arg_1_1,
                        },
                    ) => (*__self_0) != (*__arg_1_0) || (*__self_1) != (*__arg_1_1),
                    _ => unsafe { ::core::intrinsics::unreachable() },
                }
            } else {
                true
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for DiffEdit {
    #[inline]
    fn clone(&self) -> DiffEdit {
        match (&*self,) {
            (&DiffEdit::SingleElementInsert {
                index: ref __self_0,
                elem_id: ref __self_1,
                op_id: ref __self_2,
                value: ref __self_3,
            },) => DiffEdit::SingleElementInsert {
                index: ::core::clone::Clone::clone(&(*__self_0)),
                elem_id: ::core::clone::Clone::clone(&(*__self_1)),
                op_id: ::core::clone::Clone::clone(&(*__self_2)),
                value: ::core::clone::Clone::clone(&(*__self_3)),
            },
            (&DiffEdit::MultiElementInsert(ref __self_0),) => {
                DiffEdit::MultiElementInsert(::core::clone::Clone::clone(&(*__self_0)))
            }
            (&DiffEdit::Update {
                index: ref __self_0,
                op_id: ref __self_1,
                value: ref __self_2,
            },) => DiffEdit::Update {
                index: ::core::clone::Clone::clone(&(*__self_0)),
                op_id: ::core::clone::Clone::clone(&(*__self_1)),
                value: ::core::clone::Clone::clone(&(*__self_2)),
            },
            (&DiffEdit::Remove {
                index: ref __self_0,
                count: ref __self_1,
            },) => DiffEdit::Remove {
                index: ::core::clone::Clone::clone(&(*__self_0)),
                count: ::core::clone::Clone::clone(&(*__self_1)),
            },
        }
    }
}
pub struct MultiElementInsert {
    /// the list index at which to insert the first value
    pub index: u64,
    /// the unique ID of the first inserted element
    pub elem_id: ElementId,
    pub values: ScalarValues,
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for MultiElementInsert {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match *self {
            MultiElementInsert {
                index: ref __self_0_0,
                elem_id: ref __self_0_1,
                values: ref __self_0_2,
            } => {
                let debug_trait_builder =
                    &mut ::core::fmt::Formatter::debug_struct(f, "MultiElementInsert");
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "index", &&(*__self_0_0));
                let _ = ::core::fmt::DebugStruct::field(
                    debug_trait_builder,
                    "elem_id",
                    &&(*__self_0_1),
                );
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "values", &&(*__self_0_2));
                ::core::fmt::DebugStruct::finish(debug_trait_builder)
            }
        }
    }
}
impl ::core::marker::StructuralPartialEq for MultiElementInsert {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for MultiElementInsert {
    #[inline]
    fn eq(&self, other: &MultiElementInsert) -> bool {
        match *other {
            MultiElementInsert {
                index: ref __self_1_0,
                elem_id: ref __self_1_1,
                values: ref __self_1_2,
            } => match *self {
                MultiElementInsert {
                    index: ref __self_0_0,
                    elem_id: ref __self_0_1,
                    values: ref __self_0_2,
                } => {
                    (*__self_0_0) == (*__self_1_0)
                        && (*__self_0_1) == (*__self_1_1)
                        && (*__self_0_2) == (*__self_1_2)
                }
            },
        }
    }
    #[inline]
    fn ne(&self, other: &MultiElementInsert) -> bool {
        match *other {
            MultiElementInsert {
                index: ref __self_1_0,
                elem_id: ref __self_1_1,
                values: ref __self_1_2,
            } => match *self {
                MultiElementInsert {
                    index: ref __self_0_0,
                    elem_id: ref __self_0_1,
                    values: ref __self_0_2,
                } => {
                    (*__self_0_0) != (*__self_1_0)
                        || (*__self_0_1) != (*__self_1_1)
                        || (*__self_0_2) != (*__self_1_2)
                }
            },
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for MultiElementInsert {
    #[inline]
    fn clone(&self) -> MultiElementInsert {
        match *self {
            MultiElementInsert {
                index: ref __self_0_0,
                elem_id: ref __self_0_1,
                values: ref __self_0_2,
            } => MultiElementInsert {
                index: ::core::clone::Clone::clone(&(*__self_0_0)),
                elem_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                values: ::core::clone::Clone::clone(&(*__self_0_2)),
            },
        }
    }
}
#[serde(rename_all = "camelCase")]
pub struct Patch {
    #[serde(skip_serializing_if = "Option::is_none", default)]
    pub actor: Option<ActorId>,
    #[serde(skip_serializing_if = "Option::is_none", default)]
    pub seq: Option<u64>,
    pub clock: HashMap<ActorId, u64>,
    pub deps: Vec<ChangeHash>,
    pub max_op: u64,
    pub pending_changes: usize,
    pub diffs: RootDiff,
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for Patch {
    #[inline]
    fn clone(&self) -> Patch {
        match *self {
            Patch {
                actor: ref __self_0_0,
                seq: ref __self_0_1,
                clock: ref __self_0_2,
                deps: ref __self_0_3,
                max_op: ref __self_0_4,
                pending_changes: ref __self_0_5,
                diffs: ref __self_0_6,
            } => Patch {
                actor: ::core::clone::Clone::clone(&(*__self_0_0)),
                seq: ::core::clone::Clone::clone(&(*__self_0_1)),
                clock: ::core::clone::Clone::clone(&(*__self_0_2)),
                deps: ::core::clone::Clone::clone(&(*__self_0_3)),
                max_op: ::core::clone::Clone::clone(&(*__self_0_4)),
                pending_changes: ::core::clone::Clone::clone(&(*__self_0_5)),
                diffs: ::core::clone::Clone::clone(&(*__self_0_6)),
            },
        }
    }
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for Patch {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = match _serde::Serializer::serialize_struct(
                __serializer,
                "Patch",
                false as usize
                    + if Option::is_none(&self.actor) { 0 } else { 1 }
                    + if Option::is_none(&self.seq) { 0 } else { 1 }
                    + 1
                    + 1
                    + 1
                    + 1
                    + 1,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            if !Option::is_none(&self.actor) {
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "actor",
                    &self.actor,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
            } else {
                match _serde::ser::SerializeStruct::skip_field(&mut __serde_state, "actor") {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
            }
            if !Option::is_none(&self.seq) {
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "seq",
                    &self.seq,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
            } else {
                match _serde::ser::SerializeStruct::skip_field(&mut __serde_state, "seq") {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
            }
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "clock",
                &self.clock,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "deps",
                &self.deps,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "maxOp",
                &self.max_op,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "pendingChanges",
                &self.pending_changes,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "diffs",
                &self.diffs,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for Patch {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __field4,
                __field5,
                __field6,
                __ignore,
            }
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "field identifier")
                }
                fn visit_u64<__E>(self, __value: u64) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        4u64 => _serde::__private::Ok(__Field::__field4),
                        5u64 => _serde::__private::Ok(__Field::__field5),
                        6u64 => _serde::__private::Ok(__Field::__field6),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "actor" => _serde::__private::Ok(__Field::__field0),
                        "seq" => _serde::__private::Ok(__Field::__field1),
                        "clock" => _serde::__private::Ok(__Field::__field2),
                        "deps" => _serde::__private::Ok(__Field::__field3),
                        "maxOp" => _serde::__private::Ok(__Field::__field4),
                        "pendingChanges" => _serde::__private::Ok(__Field::__field5),
                        "diffs" => _serde::__private::Ok(__Field::__field6),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"actor" => _serde::__private::Ok(__Field::__field0),
                        b"seq" => _serde::__private::Ok(__Field::__field1),
                        b"clock" => _serde::__private::Ok(__Field::__field2),
                        b"deps" => _serde::__private::Ok(__Field::__field3),
                        b"maxOp" => _serde::__private::Ok(__Field::__field4),
                        b"pendingChanges" => _serde::__private::Ok(__Field::__field5),
                        b"diffs" => _serde::__private::Ok(__Field::__field6),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<Patch>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = Patch;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "struct Patch")
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match match _serde::de::SeqAccess::next_element::<Option<ActorId>>(
                        &mut __seq,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => _serde::__private::Default::default(),
                    };
                    let __field1 = match match _serde::de::SeqAccess::next_element::<Option<u64>>(
                        &mut __seq,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => _serde::__private::Default::default(),
                    };
                    let __field2 = match match _serde::de::SeqAccess::next_element::<
                        HashMap<ActorId, u64>,
                    >(&mut __seq)
                    {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(_serde::de::Error::invalid_length(
                                2usize,
                                &"struct Patch with 7 elements",
                            ));
                        }
                    };
                    let __field3 = match match _serde::de::SeqAccess::next_element::<Vec<ChangeHash>>(
                        &mut __seq,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(_serde::de::Error::invalid_length(
                                3usize,
                                &"struct Patch with 7 elements",
                            ));
                        }
                    };
                    let __field4 =
                        match match _serde::de::SeqAccess::next_element::<u64>(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    4usize,
                                    &"struct Patch with 7 elements",
                                ));
                            }
                        };
                    let __field5 =
                        match match _serde::de::SeqAccess::next_element::<usize>(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    5usize,
                                    &"struct Patch with 7 elements",
                                ));
                            }
                        };
                    let __field6 =
                        match match _serde::de::SeqAccess::next_element::<RootDiff>(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    6usize,
                                    &"struct Patch with 7 elements",
                                ));
                            }
                        };
                    _serde::__private::Ok(Patch {
                        actor: __field0,
                        seq: __field1,
                        clock: __field2,
                        deps: __field3,
                        max_op: __field4,
                        pending_changes: __field5,
                        diffs: __field6,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<Option<ActorId>> =
                        _serde::__private::None;
                    let mut __field1: _serde::__private::Option<Option<u64>> =
                        _serde::__private::None;
                    let mut __field2: _serde::__private::Option<HashMap<ActorId, u64>> =
                        _serde::__private::None;
                    let mut __field3: _serde::__private::Option<Vec<ChangeHash>> =
                        _serde::__private::None;
                    let mut __field4: _serde::__private::Option<u64> = _serde::__private::None;
                    let mut __field5: _serde::__private::Option<usize> = _serde::__private::None;
                    let mut __field6: _serde::__private::Option<RootDiff> = _serde::__private::None;
                    while let _serde::__private::Some(__key) =
                        match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        }
                    {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("actor"),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<Option<ActorId>>(
                                        &mut __map,
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("seq"),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<Option<u64>>(
                                        &mut __map,
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private::Option::is_some(&__field2) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("clock"),
                                    );
                                }
                                __field2 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<HashMap<ActorId, u64>>(
                                        &mut __map,
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field3 => {
                                if _serde::__private::Option::is_some(&__field3) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("deps"),
                                    );
                                }
                                __field3 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<Vec<ChangeHash>>(
                                        &mut __map,
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field4 => {
                                if _serde::__private::Option::is_some(&__field4) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("maxOp"),
                                    );
                                }
                                __field4 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<u64>(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field5 => {
                                if _serde::__private::Option::is_some(&__field5) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "pendingChanges",
                                        ),
                                    );
                                }
                                __field5 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<usize>(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field6 => {
                                if _serde::__private::Option::is_some(&__field6) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("diffs"),
                                    );
                                }
                                __field6 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<RootDiff>(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            _ => {
                                let _ = match _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)
                                {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => _serde::__private::Default::default(),
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => _serde::__private::Default::default(),
                    };
                    let __field2 = match __field2 {
                        _serde::__private::Some(__field2) => __field2,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("clock") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    let __field3 = match __field3 {
                        _serde::__private::Some(__field3) => __field3,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("deps") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    let __field4 = match __field4 {
                        _serde::__private::Some(__field4) => __field4,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("maxOp") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    let __field5 = match __field5 {
                        _serde::__private::Some(__field5) => __field5,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("pendingChanges") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    let __field6 = match __field6 {
                        _serde::__private::Some(__field6) => __field6,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("diffs") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    _serde::__private::Ok(Patch {
                        actor: __field0,
                        seq: __field1,
                        clock: __field2,
                        deps: __field3,
                        max_op: __field4,
                        pending_changes: __field5,
                        diffs: __field6,
                    })
                }
            }
            const FIELDS: &'static [&'static str] = &[
                "actor",
                "seq",
                "clock",
                "deps",
                "maxOp",
                "pendingChanges",
                "diffs",
            ];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "Patch",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<Patch>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for Patch {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match *self {
            Patch {
                actor: ref __self_0_0,
                seq: ref __self_0_1,
                clock: ref __self_0_2,
                deps: ref __self_0_3,
                max_op: ref __self_0_4,
                pending_changes: ref __self_0_5,
                diffs: ref __self_0_6,
            } => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_struct(f, "Patch");
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "actor", &&(*__self_0_0));
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "seq", &&(*__self_0_1));
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "clock", &&(*__self_0_2));
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "deps", &&(*__self_0_3));
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "max_op", &&(*__self_0_4));
                let _ = ::core::fmt::DebugStruct::field(
                    debug_trait_builder,
                    "pending_changes",
                    &&(*__self_0_5),
                );
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "diffs", &&(*__self_0_6));
                ::core::fmt::DebugStruct::finish(debug_trait_builder)
            }
        }
    }
}
impl ::core::marker::StructuralPartialEq for Patch {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for Patch {
    #[inline]
    fn eq(&self, other: &Patch) -> bool {
        match *other {
            Patch {
                actor: ref __self_1_0,
                seq: ref __self_1_1,
                clock: ref __self_1_2,
                deps: ref __self_1_3,
                max_op: ref __self_1_4,
                pending_changes: ref __self_1_5,
                diffs: ref __self_1_6,
            } => match *self {
                Patch {
                    actor: ref __self_0_0,
                    seq: ref __self_0_1,
                    clock: ref __self_0_2,
                    deps: ref __self_0_3,
                    max_op: ref __self_0_4,
                    pending_changes: ref __self_0_5,
                    diffs: ref __self_0_6,
                } => {
                    (*__self_0_0) == (*__self_1_0)
                        && (*__self_0_1) == (*__self_1_1)
                        && (*__self_0_2) == (*__self_1_2)
                        && (*__self_0_3) == (*__self_1_3)
                        && (*__self_0_4) == (*__self_1_4)
                        && (*__self_0_5) == (*__self_1_5)
                        && (*__self_0_6) == (*__self_1_6)
                }
            },
        }
    }
    #[inline]
    fn ne(&self, other: &Patch) -> bool {
        match *other {
            Patch {
                actor: ref __self_1_0,
                seq: ref __self_1_1,
                clock: ref __self_1_2,
                deps: ref __self_1_3,
                max_op: ref __self_1_4,
                pending_changes: ref __self_1_5,
                diffs: ref __self_1_6,
            } => match *self {
                Patch {
                    actor: ref __self_0_0,
                    seq: ref __self_0_1,
                    clock: ref __self_0_2,
                    deps: ref __self_0_3,
                    max_op: ref __self_0_4,
                    pending_changes: ref __self_0_5,
                    diffs: ref __self_0_6,
                } => {
                    (*__self_0_0) != (*__self_1_0)
                        || (*__self_0_1) != (*__self_1_1)
                        || (*__self_0_2) != (*__self_1_2)
                        || (*__self_0_3) != (*__self_1_3)
                        || (*__self_0_4) != (*__self_1_4)
                        || (*__self_0_5) != (*__self_1_5)
                        || (*__self_0_6) != (*__self_1_6)
                }
            },
        }
    }
}
/// A custom MapDiff that implicitly has the object_id Root and is a map object.
pub struct RootDiff {
    pub props: HashMap<String, HashMap<OpId, Diff>>,
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for RootDiff {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match *self {
            RootDiff {
                props: ref __self_0_0,
            } => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_struct(f, "RootDiff");
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "props", &&(*__self_0_0));
                ::core::fmt::DebugStruct::finish(debug_trait_builder)
            }
        }
    }
}
impl ::core::marker::StructuralPartialEq for RootDiff {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for RootDiff {
    #[inline]
    fn eq(&self, other: &RootDiff) -> bool {
        match *other {
            RootDiff {
                props: ref __self_1_0,
            } => match *self {
                RootDiff {
                    props: ref __self_0_0,
                } => (*__self_0_0) == (*__self_1_0),
            },
        }
    }
    #[inline]
    fn ne(&self, other: &RootDiff) -> bool {
        match *other {
            RootDiff {
                props: ref __self_1_0,
            } => match *self {
                RootDiff {
                    props: ref __self_0_0,
                } => (*__self_0_0) != (*__self_1_0),
            },
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for RootDiff {
    #[inline]
    fn clone(&self) -> RootDiff {
        match *self {
            RootDiff {
                props: ref __self_0_0,
            } => RootDiff {
                props: ::core::clone::Clone::clone(&(*__self_0_0)),
            },
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::default::Default for RootDiff {
    #[inline]
    fn default() -> RootDiff {
        RootDiff {
            props: ::core::default::Default::default(),
        }
    }
}
pub struct UncompressedChange {
    #[serde(rename = "ops")]
    pub operations: Vec<Op>,
    #[serde(rename = "actor")]
    pub actor_id: ActorId,
    #[serde(skip_serializing_if = "Option::is_none", default)]
    pub hash: Option<ChangeHash>,
    pub seq: u64,
    #[serde(rename = "startOp")]
    pub start_op: u64,
    pub time: i64,
    pub message: Option<String>,
    pub deps: Vec<ChangeHash>,
    #[serde(skip_serializing_if = "Vec::is_empty", default = "Default::default")]
    pub extra_bytes: Vec<u8>,
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for UncompressedChange {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __field4,
                __field5,
                __field6,
                __field7,
                __field8,
                __ignore,
            }
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "field identifier")
                }
                fn visit_u64<__E>(self, __value: u64) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        4u64 => _serde::__private::Ok(__Field::__field4),
                        5u64 => _serde::__private::Ok(__Field::__field5),
                        6u64 => _serde::__private::Ok(__Field::__field6),
                        7u64 => _serde::__private::Ok(__Field::__field7),
                        8u64 => _serde::__private::Ok(__Field::__field8),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "ops" => _serde::__private::Ok(__Field::__field0),
                        "actor" => _serde::__private::Ok(__Field::__field1),
                        "hash" => _serde::__private::Ok(__Field::__field2),
                        "seq" => _serde::__private::Ok(__Field::__field3),
                        "startOp" => _serde::__private::Ok(__Field::__field4),
                        "time" => _serde::__private::Ok(__Field::__field5),
                        "message" => _serde::__private::Ok(__Field::__field6),
                        "deps" => _serde::__private::Ok(__Field::__field7),
                        "extra_bytes" => _serde::__private::Ok(__Field::__field8),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"ops" => _serde::__private::Ok(__Field::__field0),
                        b"actor" => _serde::__private::Ok(__Field::__field1),
                        b"hash" => _serde::__private::Ok(__Field::__field2),
                        b"seq" => _serde::__private::Ok(__Field::__field3),
                        b"startOp" => _serde::__private::Ok(__Field::__field4),
                        b"time" => _serde::__private::Ok(__Field::__field5),
                        b"message" => _serde::__private::Ok(__Field::__field6),
                        b"deps" => _serde::__private::Ok(__Field::__field7),
                        b"extra_bytes" => _serde::__private::Ok(__Field::__field8),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<UncompressedChange>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = UncompressedChange;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct UncompressedChange",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 =
                        match match _serde::de::SeqAccess::next_element::<Vec<Op>>(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct UncompressedChange with 9 elements",
                                ));
                            }
                        };
                    let __field1 =
                        match match _serde::de::SeqAccess::next_element::<ActorId>(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct UncompressedChange with 9 elements",
                                ));
                            }
                        };
                    let __field2 = match match _serde::de::SeqAccess::next_element::<
                        Option<ChangeHash>,
                    >(&mut __seq)
                    {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => _serde::__private::Default::default(),
                    };
                    let __field3 =
                        match match _serde::de::SeqAccess::next_element::<u64>(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct UncompressedChange with 9 elements",
                                ));
                            }
                        };
                    let __field4 =
                        match match _serde::de::SeqAccess::next_element::<u64>(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    4usize,
                                    &"struct UncompressedChange with 9 elements",
                                ));
                            }
                        };
                    let __field5 =
                        match match _serde::de::SeqAccess::next_element::<i64>(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    5usize,
                                    &"struct UncompressedChange with 9 elements",
                                ));
                            }
                        };
                    let __field6 = match match _serde::de::SeqAccess::next_element::<Option<String>>(
                        &mut __seq,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(_serde::de::Error::invalid_length(
                                6usize,
                                &"struct UncompressedChange with 9 elements",
                            ));
                        }
                    };
                    let __field7 = match match _serde::de::SeqAccess::next_element::<Vec<ChangeHash>>(
                        &mut __seq,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(_serde::de::Error::invalid_length(
                                7usize,
                                &"struct UncompressedChange with 9 elements",
                            ));
                        }
                    };
                    let __field8 =
                        match match _serde::de::SeqAccess::next_element::<Vec<u8>>(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => Default::default(),
                        };
                    _serde::__private::Ok(UncompressedChange {
                        operations: __field0,
                        actor_id: __field1,
                        hash: __field2,
                        seq: __field3,
                        start_op: __field4,
                        time: __field5,
                        message: __field6,
                        deps: __field7,
                        extra_bytes: __field8,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<Vec<Op>> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<ActorId> = _serde::__private::None;
                    let mut __field2: _serde::__private::Option<Option<ChangeHash>> =
                        _serde::__private::None;
                    let mut __field3: _serde::__private::Option<u64> = _serde::__private::None;
                    let mut __field4: _serde::__private::Option<u64> = _serde::__private::None;
                    let mut __field5: _serde::__private::Option<i64> = _serde::__private::None;
                    let mut __field6: _serde::__private::Option<Option<String>> =
                        _serde::__private::None;
                    let mut __field7: _serde::__private::Option<Vec<ChangeHash>> =
                        _serde::__private::None;
                    let mut __field8: _serde::__private::Option<Vec<u8>> = _serde::__private::None;
                    while let _serde::__private::Some(__key) =
                        match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        }
                    {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("ops"),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<Vec<Op>>(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("actor"),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<ActorId>(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private::Option::is_some(&__field2) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("hash"),
                                    );
                                }
                                __field2 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<Option<ChangeHash>>(
                                        &mut __map,
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field3 => {
                                if _serde::__private::Option::is_some(&__field3) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("seq"),
                                    );
                                }
                                __field3 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<u64>(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field4 => {
                                if _serde::__private::Option::is_some(&__field4) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "startOp",
                                        ),
                                    );
                                }
                                __field4 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<u64>(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field5 => {
                                if _serde::__private::Option::is_some(&__field5) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("time"),
                                    );
                                }
                                __field5 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<i64>(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field6 => {
                                if _serde::__private::Option::is_some(&__field6) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "message",
                                        ),
                                    );
                                }
                                __field6 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<Option<String>>(
                                        &mut __map,
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field7 => {
                                if _serde::__private::Option::is_some(&__field7) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("deps"),
                                    );
                                }
                                __field7 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<Vec<ChangeHash>>(
                                        &mut __map,
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field8 => {
                                if _serde::__private::Option::is_some(&__field8) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "extra_bytes",
                                        ),
                                    );
                                }
                                __field8 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<Vec<u8>>(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            _ => {
                                let _ = match _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)
                                {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("ops") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("actor") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private::Some(__field2) => __field2,
                        _serde::__private::None => _serde::__private::Default::default(),
                    };
                    let __field3 = match __field3 {
                        _serde::__private::Some(__field3) => __field3,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("seq") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    let __field4 = match __field4 {
                        _serde::__private::Some(__field4) => __field4,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("startOp") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    let __field5 = match __field5 {
                        _serde::__private::Some(__field5) => __field5,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("time") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    let __field6 = match __field6 {
                        _serde::__private::Some(__field6) => __field6,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("message") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    let __field7 = match __field7 {
                        _serde::__private::Some(__field7) => __field7,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("deps") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    let __field8 = match __field8 {
                        _serde::__private::Some(__field8) => __field8,
                        _serde::__private::None => Default::default(),
                    };
                    _serde::__private::Ok(UncompressedChange {
                        operations: __field0,
                        actor_id: __field1,
                        hash: __field2,
                        seq: __field3,
                        start_op: __field4,
                        time: __field5,
                        message: __field6,
                        deps: __field7,
                        extra_bytes: __field8,
                    })
                }
            }
            const FIELDS: &'static [&'static str] = &[
                "ops",
                "actor",
                "hash",
                "seq",
                "startOp",
                "time",
                "message",
                "deps",
                "extra_bytes",
            ];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "UncompressedChange",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<UncompressedChange>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for UncompressedChange {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = match _serde::Serializer::serialize_struct(
                __serializer,
                "UncompressedChange",
                false as usize
                    + 1
                    + 1
                    + if Option::is_none(&self.hash) { 0 } else { 1 }
                    + 1
                    + 1
                    + 1
                    + 1
                    + 1
                    + if Vec::is_empty(&self.extra_bytes) {
                        0
                    } else {
                        1
                    },
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "ops",
                &self.operations,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "actor",
                &self.actor_id,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            if !Option::is_none(&self.hash) {
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "hash",
                    &self.hash,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
            } else {
                match _serde::ser::SerializeStruct::skip_field(&mut __serde_state, "hash") {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
            }
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "seq",
                &self.seq,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "startOp",
                &self.start_op,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "time",
                &self.time,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "message",
                &self.message,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "deps",
                &self.deps,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            if !Vec::is_empty(&self.extra_bytes) {
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "extra_bytes",
                    &self.extra_bytes,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
            } else {
                match _serde::ser::SerializeStruct::skip_field(&mut __serde_state, "extra_bytes") {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
            }
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for UncompressedChange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match *self {
            UncompressedChange {
                operations: ref __self_0_0,
                actor_id: ref __self_0_1,
                hash: ref __self_0_2,
                seq: ref __self_0_3,
                start_op: ref __self_0_4,
                time: ref __self_0_5,
                message: ref __self_0_6,
                deps: ref __self_0_7,
                extra_bytes: ref __self_0_8,
            } => {
                let debug_trait_builder =
                    &mut ::core::fmt::Formatter::debug_struct(f, "UncompressedChange");
                let _ = ::core::fmt::DebugStruct::field(
                    debug_trait_builder,
                    "operations",
                    &&(*__self_0_0),
                );
                let _ = ::core::fmt::DebugStruct::field(
                    debug_trait_builder,
                    "actor_id",
                    &&(*__self_0_1),
                );
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "hash", &&(*__self_0_2));
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "seq", &&(*__self_0_3));
                let _ = ::core::fmt::DebugStruct::field(
                    debug_trait_builder,
                    "start_op",
                    &&(*__self_0_4),
                );
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "time", &&(*__self_0_5));
                let _ = ::core::fmt::DebugStruct::field(
                    debug_trait_builder,
                    "message",
                    &&(*__self_0_6),
                );
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "deps", &&(*__self_0_7));
                let _ = ::core::fmt::DebugStruct::field(
                    debug_trait_builder,
                    "extra_bytes",
                    &&(*__self_0_8),
                );
                ::core::fmt::DebugStruct::finish(debug_trait_builder)
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for UncompressedChange {
    #[inline]
    fn clone(&self) -> UncompressedChange {
        match *self {
            UncompressedChange {
                operations: ref __self_0_0,
                actor_id: ref __self_0_1,
                hash: ref __self_0_2,
                seq: ref __self_0_3,
                start_op: ref __self_0_4,
                time: ref __self_0_5,
                message: ref __self_0_6,
                deps: ref __self_0_7,
                extra_bytes: ref __self_0_8,
            } => UncompressedChange {
                operations: ::core::clone::Clone::clone(&(*__self_0_0)),
                actor_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                hash: ::core::clone::Clone::clone(&(*__self_0_2)),
                seq: ::core::clone::Clone::clone(&(*__self_0_3)),
                start_op: ::core::clone::Clone::clone(&(*__self_0_4)),
                time: ::core::clone::Clone::clone(&(*__self_0_5)),
                message: ::core::clone::Clone::clone(&(*__self_0_6)),
                deps: ::core::clone::Clone::clone(&(*__self_0_7)),
                extra_bytes: ::core::clone::Clone::clone(&(*__self_0_8)),
            },
        }
    }
}
impl PartialEq for UncompressedChange {
    fn eq(&self, other: &Self) -> bool {
        self.operations == other.operations
            && self.actor_id == other.actor_id
            && self.seq == other.seq
            && self.start_op == other.start_op
            && self.time == other.time
            && self.message == other.message
            && self.deps == other.deps
            && self.extra_bytes == other.extra_bytes
    }
}
impl UncompressedChange {
    pub fn op_id_of(&self, index: u64) -> Option<OpId> {
        if let Ok(index_usize) = usize::try_from(index) {
            if index_usize < self.operations.len() {
                return Some(self.actor_id.op_id_at(self.start_op + index));
            }
        }
        None
    }
}
